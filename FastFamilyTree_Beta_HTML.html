<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fast Family Tree App by genescreen inc.</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#f0f9ff',
                            100: '#e0f2fe',
                            200: '#bae6fd',
                            300: '#7dd3fc',
                            400: '#38bdf8',
                            500: '#0ea5e9',
                            600: '#0284c7',
                            700: '#0369a1',
                            800: '#075985',
                            900: '#0c4a6e'
                        },
                        success: {
                            50: '#f0fdf4',
                            100: '#dcfce7',
                            200: '#bbf7d0',
                            300: '#86efac',
                            400: '#4ade80',
                            500: '#22c55e',
                            600: '#16a34a',
                            700: '#15803d',
                            800: '#166534',
                            900: '#14532d'
                        },
                        warning: {
                            50: '#fffbeb',
                            100: '#fef3c7',
                            200: '#fde68a',
                            300: '#fcd34d',
                            400: '#fbbf24',
                            500: '#f59e0b',
                            600: '#d97706',
                            700: '#b45309',
                            800: '#92400e',
                            900: '#78350f'
                        },
                        danger: {
                            50: '#fef2f2',
                            100: '#fee2e2',
                            200: '#fecaca',
                            300: '#fca5a5',
                            400: '#f87171',
                            500: '#ef4444',
                            600: '#dc2626',
                            700: '#b91c1c',
                            800: '#991b1b',
                            900: '#7f1d1d'
                        },
                        neutral: {
                            50: '#fafafa',
                            100: '#f5f5f5',
                            200: '#e5e5e5',
                            300: '#d4d4d4',
                            400: '#a3a3a3',
                            500: '#737373',
                            600: '#525252',
                            700: '#404040',
                            800: '#262626',
                            900: '#171717'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .pedigree-canvas {
            cursor: crosshair;
            min-height: 800px;
            display: block;
        }

        .symbol-preview {
            width: 24px;
            height: 24px;
            display: inline-block;
            margin-right: 8px;
        }

        /* Draggable tools panel styling */
        #draggable-tools {
            user-select: none;
        }

        #tools-drag-handle {
            cursor: move;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        #tools-drag-handle:hover {
            background-color: rgba(93, 92, 222, 0.1);
        }

        #tools-drag-handle:active {
            cursor: grabbing;
            background-color: rgba(93, 92, 222, 0.2);
        }

        /* Selected button styling - Scale + Shadow Effect */
        .selected-symbol {
            transform: scale(1.10) translateY(-2px) !important;
            box-shadow: 0 12px 24px rgba(93, 92, 222, 0.4), 
                        0 6px 12px rgba(0, 0, 0, 0.15) !important;
            transition: all 0.2s ease;
            z-index: 10;
            position: relative;
        }

        /* Enhanced hover effect for non-selected buttons */
        button[id^="btn-"]:not(.selected-symbol):hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        /* Ensure selected state overrides hover */
        .selected-symbol:hover {
            transform: scale(1.10) translateY(-2px) !important;
            box-shadow: 0 16px 32px rgba(93, 92, 222, 0.5),
                        0 8px 16px rgba(0, 0, 0, 0.2) !important;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white transition-colors duration-200">
    <!-- Header -->
    <header class="sticky top-0 z-40 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-3">
        <div class="max-w-7xl mx-auto">
            <div class="flex items-center flex-wrap gap-4">
                <div>
                    <h1 class="text-xl font-bold text-primary">FastFamilyTree App by GeneScreen inc.</h1>
                    <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Create standardized medical pedigrees</p>
                </div>
                <div class="flex items-center space-x-6 ml-6">
                    <button id="btn-jump-instructions" class="flex items-center gap-1 text-gray-900 dark:text-gray-100 hover:text-gray-600 dark:hover:text-gray-400 transition-colors text-sm whitespace-nowrap">
                        <span>üìò</span>
                        <span>User Guide</span>
                    </button>
                    <button id="btn-save" class="flex items-center gap-1 text-gray-900 dark:text-gray-100 hover:text-gray-600 dark:hover:text-gray-400 transition-colors text-sm whitespace-nowrap">
                        <span>üíæ</span>
                        <span>Save Canvas</span>
                    </button>
                    <button id="btn-load" class="flex items-center gap-1 text-gray-900 dark:text-gray-100 hover:text-gray-600 dark:hover:text-gray-400 transition-colors text-sm whitespace-nowrap">
                        <span>üìÅ</span>
                        <span>Load Canvas</span>
                    </button>
                    <button id="btn-download" class="flex items-center gap-1 text-gray-900 dark:text-gray-100 hover:text-gray-600 dark:hover:text-gray-400 transition-colors text-sm whitespace-nowrap">
                        <span>üìÑ</span>
                        <span>Download PDF</span>
                    </button>
                    <button id="btn-feedback" class="relative px-4 py-2.5 bg-gradient-to-r from-orange-500 to-orange-600 text-white rounded-lg hover:from-orange-600 hover:to-orange-700 transition-all text-base whitespace-nowrap shadow-lg hover:shadow-xl font-semibold border-2 border-orange-300" title="Share your thoughts! Click to send feedback to our team">
                        üìù Feedback
                        <span class="absolute -top-2 -right-2 bg-red-500 text-white text-xs font-bold px-2 py-0.5 rounded-full">BETA</span>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Toolbar -->
    <div class="sticky top-[76px] z-30 bg-gray-100 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-3">
        <div class="max-w-7xl mx-auto">
            <!-- Pattern Legend -->
            <div class="mb-3 p-2 bg-white dark:bg-gray-700 rounded border border-gray-200 dark:border-gray-600">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-xs font-semibold">Disorder Pattern Legend:</h3>
                    <div class="flex items-center space-x-2">
                        <button id="addPatternBtn" class="px-2 py-1 bg-primary-600 text-white text-xs rounded hover:bg-primary-700 transition-colors">+ Add Condition</button>
                        <button id="togglePatternLegend" class="text-xs text-primary hover:text-primary/80">
                            <span id="legendToggleText">Collapse</span>
                        </button>
                    </div>
                </div>

                <div id="patternLegendContent">
                    <div id="patternList" class="space-y-2">
                        <!-- Dynamic pattern entries will be added here -->
                    </div>
                    <div id="emptyPatternMessage" class="text-center py-3 text-xs text-gray-500 dark:text-gray-400">
                        No disorder patterns defined yet. Click "+ Add Condition" to create your first pattern.
                    </div>
                    <div class="mt-2 pt-2 border-t border-gray-200 dark:border-gray-600">
                        <p class="text-xs text-gray-600 dark:text-gray-400">
                            <strong>Tip:</strong> Each quadrant of a symbol can show a different pattern. Create patterns only for disorders you need to track in your pedigree.
                        </p>
                    </div>
                </div>
            </div>

            <div class="space-y-2">
                <!-- Row 1: Add Symbol Tools -->
                <div class="flex flex-wrap gap-2 items-center">
                    <label class="text-xs font-medium">Add Symbol:</label>
                    <button id="btn-male" class="flex items-center px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">
                        <canvas class="symbol-preview" width="24" height="24"></canvas>Male
                    </button>
                    <button id="btn-female" class="flex items-center px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">
                        <canvas class="symbol-preview" width="24" height="24"></canvas>Female
                    </button>
                    <button id="btn-unknown" class="flex items-center px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">
                        <canvas class="symbol-preview" width="24" height="24"></canvas>Unknown
                    </button>
                    <button id="btn-proband" class="flex items-center px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">
                        <canvas class="symbol-preview" width="24" height="24"></canvas>Proband
                    </button>
                    <button id="btn-pregnancy" class="flex items-center px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">
                        <canvas class="symbol-preview" width="24" height="24"></canvas>Pregnancy
                    </button>
                    <button id="btn-miscarriage" class="flex items-center px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">
                        <canvas class="symbol-preview" width="24" height="24"></canvas>Miscarriage
                    </button>
                    <button id="btn-tab" class="flex items-center px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">
                        <canvas class="symbol-preview" width="24" height="24"></canvas>TAB
                    </button>
                    <button id="btn-ectopic" class="flex items-center px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">
                        <canvas class="symbol-preview" width="24" height="24"></canvas>Ectopic Pregnancy
                    </button>
                </div>

                <!-- Row 2: Connection Tools + Editing Tools -->
                <div class="flex flex-wrap gap-2 items-center">
                    <label class="text-xs font-medium">Connect:</label>
                    <button id="btn-connect-family" class="px-2 py-1 bg-emerald-600 text-white rounded hover:bg-emerald-700 transition-colors text-sm">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Connect as Family</button>
                    <button id="btn-marriage" class="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">Union</button>
                    <button id="btn-consanguineous" class="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">Consang. Union</button>
                    <button id="btn-siblings" class="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">Siblings</button>
                    <button id="btn-multiples" class="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">Multiples</button>
                    <button id="btn-identical" class="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors text-sm">Identical</button>
                    
                    <!-- Separator -->
                    <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 mx-2"></div>
                    
                    <!-- Edit Tools -->
                    <button id="btn-deceased" class="px-2 py-1 bg-warning-600 text-white rounded hover:bg-warning-700 transition-colors text-sm">Deceased</button>
                    <button id="btn-separated" class="px-2 py-1 bg-danger-600 text-white rounded hover:bg-danger-700 transition-colors text-sm">Separated</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Fixed Tools Column -->
    <div id="draggable-tools" class="fixed left-4 top-[320px] z-30 bg-white dark:bg-gray-900 p-3 rounded-lg border border-gray-200 dark:border-gray-700 shadow-lg w-32">
        <div class="flex flex-col space-y-2">
            <label id="tools-drag-handle" class="text-xs font-medium text-gray-700 dark:text-gray-300 text-center cursor-move select-none">Tools: ‚†ø</label>

            <button id="btn-textbox" class="flex items-center justify-center px-2 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition-colors text-sm whitespace-nowrap">Text Box</button>
            <button id="btn-undo" class="flex items-center justify-center px-2 py-2 bg-orange-500 text-white rounded hover:bg-orange-600 transition-colors text-sm disabled:bg-gray-400 disabled:cursor-not-allowed whitespace-nowrap" disabled>Undo</button>
            <button id="btn-copy" class="flex items-center justify-center px-2 py-2 bg-teal-500 text-white rounded hover:bg-teal-600 transition-colors text-sm whitespace-nowrap">Copy</button>
            <button id="btn-paste" class="flex items-center justify-center px-2 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors text-sm disabled:bg-gray-400 disabled:cursor-not-allowed whitespace-nowrap">Paste</button>
            <button id="btn-delete" class="flex items-center justify-center px-2 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors text-sm whitespace-nowrap">Delete</button>
            <button id="btn-clear" class="flex items-center justify-center px-2 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors text-sm whitespace-nowrap">Clear</button>
        </div>
    </div>

    <!-- Main Canvas Area - Scrollable -->
    <div class="flex-1 p-4 pl-[140px]"> <!-- Left padding to account for fixed tools column -->
        <div class="max-w-7xl mx-auto">
            <div class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                <canvas id="pedigreeCanvas" class="pedigree-canvas w-full" width="1200" height="800"></canvas>
            </div>
        </div>
    </div>

    <!-- Hidden file input for loading canvas -->
    <input type="file" id="loadFileInput" accept=".json" style="display: none;" onchange="loadCanvasFromFile(event)">

    <!-- Text Box Edit Modal -->
    <div id="textBoxModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full max-h-screen overflow-y-auto">
            <h3 class="text-lg font-semibold mb-4">Edit Text Box</h3>
            <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium mb-1">Text:</label>
                    <textarea id="textBoxContent" rows="6" maxlength="300" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base resize-none" placeholder="Enter your text here (up to 300 characters)..."></textarea>
                    <div class="flex justify-between items-center mt-1">
                        <span class="text-xs text-gray-500 dark:text-gray-400">Up to 300 characters</span>
                        <span id="charCount" class="text-xs text-gray-500 dark:text-gray-400">0/300</span>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Font Size:</label>
                    <select id="textBoxFontSize" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                        <option value="10">10px</option>
                        <option value="12">12px</option>
                        <option value="14" selected>14px</option>
                        <option value="16">16px</option>
                        <option value="18">18px</option>
                        <option value="20">20px</option>
                        <option value="24">24px</option>
                    </select>
                </div>
            </div>
            <div class="flex justify-end space-x-3 mt-6">
                <button onclick="closeTextBoxModal()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base">Cancel</button>
                <button onclick="saveTextBoxInfo()" class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-base">Save</button>
            </div>
        </div>
    </div>



    <!-- Pregnancy Info Modal -->
    <div id="pregnancyModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
            <h3 class="text-lg font-semibold mb-4">Pregnancy Information</h3>
            <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium mb-1">LMP (Last Menstrual Period):</label>
                    <input type="date" id="pregnancyLMP" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">EDC (Expected Date of Confinement):</label>
                    <input type="date" id="pregnancyEDC" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Notes:</label>
                    <textarea id="pregnancyNotes" rows="3" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="Additional pregnancy information..."></textarea>
                </div>
                
                <!-- Maternal Complications -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                    <label class="block text-sm font-medium mb-2">Maternal Complications:</label>
                    <div class="grid grid-cols-2 gap-2 text-sm">
                        <label class="flex items-center">
                            <input type="checkbox" id="maternalHypertension" class="mr-2">
                            <span>Hypertension</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="maternalPreeclampsia" class="mr-2">
                            <span>Preeclampsia</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="maternalGestationalDiabetes" class="mr-2">
                            <span>Gestational diabetes</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="maternalIDDM" class="mr-2">
                            <span>IDDM</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="maternalTeratogenicExposure" class="mr-2">
                            <span>Teratogenic exposure</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="maternalPlacentalBleeding" class="mr-2">
                            <span>Placental bleeding</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="maternalOther" class="mr-2">
                            <span>Other</span>
                        </label>
                    </div>
                </div>
                
                <!-- Fetal Complications -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                    <label class="block text-sm font-medium mb-2">Fetal Complications:</label>
                    <div class="grid grid-cols-2 gap-2 text-sm">
                        <label class="flex items-center">
                            <input type="checkbox" id="fetalIUGR" class="mr-2">
                            <span>IUGR</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="fetalPosNIPT" class="mr-2">
                            <span>POS NIPT or FTS</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="fetalOligoPolyHydramnios" class="mr-2">
                            <span>Oligo/poly hydramnios</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="fetal3VesselCord" class="mr-2">
                            <span>3 vessel cord</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="fetalSoftSignsUS" class="mr-2">
                            <span>Soft signs on US</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="fetalOther" class="mr-2">
                            <span>Other</span>
                        </label>
                    </div>
                </div>
                
                <!-- Display Options -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                    <label class="block text-sm font-medium mb-2">Display Options:</label>
                    <div class="space-y-2">
                        <label class="flex items-center">
                            <input type="checkbox" id="showPregnancyNotes" class="mr-2">
                            <span class="text-sm">Show Notes on Family Tree</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showMaternalComplications" class="mr-2">
                            <span class="text-sm">Show Maternal Complications</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showFetalComplications" class="mr-2">
                            <span class="text-sm">Show Fetal Complications</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="flex justify-end space-x-3 mt-6">
                <button onclick="closePregnancyModal()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base">Cancel</button>
                <button onclick="savePregnancyInfo()" class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-base">Save</button>
            </div>
        </div>
    </div>

    <!-- Miscarriage Info Modal -->
    <div id="miscarriageModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
            <h3 class="text-lg font-semibold mb-4">Miscarriage Information</h3>
            <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium mb-1">Weeks Gestation:</label>
                    <input type="number" id="miscarriageGestation" min="0" max="42" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="e.g., 8">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Fetal Anomalies:</label>
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center">
                            <input type="radio" id="fetalAnomaliesYes" name="fetalAnomalies" value="yes" class="mr-2">
                            <span class="text-sm">Yes</span>
                        </label>
                        <label class="flex items-center">
                            <input type="radio" id="fetalAnomaliesNo" name="fetalAnomalies" value="no" class="mr-2">
                            <span class="text-sm">No</span>
                        </label>
                        <label class="flex items-center">
                            <input type="radio" id="fetalAnomaliesUnknown" name="fetalAnomalies" value="unknown" class="mr-2">
                            <span class="text-sm">Unknown</span>
                        </label>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Comments:</label>
                    <textarea id="miscarriageComments" rows="3" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="Additional information about the miscarriage..."></textarea>
                </div>
                
                <!-- Display Options -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                    <label class="block text-sm font-medium mb-2">Display Options:</label>
                    <div class="space-y-2">
                        <label class="flex items-center">
                            <input type="checkbox" id="showMiscarriageGestation" class="mr-2">
                            <span class="text-sm">Show Weeks Gestation</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showFetalAnomalies" class="mr-2">
                            <span class="text-sm">Show Fetal Anomalies</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showMiscarriageComments" class="mr-2">
                            <span class="text-sm">Show Comments</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="flex justify-end space-x-3 mt-6">
                <button onclick="closeMiscarriageModal()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base">Cancel</button>
                <button onclick="saveMiscarriageInfo()" class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-base">Save</button>
            </div>
        </div>
    </div>

    <!-- TAB (Terminated Pregnancy) Info Modal -->
    <div id="tabModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
            <h3 class="text-lg font-semibold mb-4">TAB (Terminated Pregnancy) Information</h3>
            <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium mb-1">Gestation (weeks):</label>
                    <input type="number" id="tabGestation" min="0" max="42" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="e.g., 12">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Reason for termination:</label>
                    <select id="tabReason" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                        <option value="">Select reason</option>
                        <option value="maternal-health">Maternal health</option>
                        <option value="fetal-abnormality">Fetal abnormality</option>
                        <option value="genetic-disorder">Genetic disorder</option>
                        <option value="personal-choice">Personal choice</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Additional comments:</label>
                    <textarea id="tabComments" rows="3" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="Additional information..."></textarea>
                </div>
                
                <!-- Display Options -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                    <label class="block text-sm font-medium mb-2">Display Options:</label>
                    <div class="space-y-2">
                        <label class="flex items-center">
                            <input type="checkbox" id="showTabGestation" class="mr-2">
                            <span class="text-sm">Show Gestation</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showTabReason" class="mr-2">
                            <span class="text-sm">Show Reason</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showTabComments" class="mr-2">
                            <span class="text-sm">Show Comments</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="flex justify-end space-x-3 mt-6">
                <button onclick="closeTabModal()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base">Cancel</button>
                <button onclick="saveTabInfo()" class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-base">Save</button>
            </div>
        </div>
    </div>

    <!-- Ectopic Pregnancy Info Modal -->
    <div id="ectopicModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
            <h3 class="text-lg font-semibold mb-4">Ectopic Pregnancy Information</h3>
            <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium mb-1">Year:</label>
                    <input type="number" id="ectopicYear" min="1900" max="2100" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="e.g., 2023">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Comments:</label>
                    <textarea id="ectopicComments" rows="3" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="Additional information about the ectopic pregnancy..."></textarea>
                </div>
            </div>
            <div class="flex justify-end space-x-3 mt-6">
                <button onclick="closeEctopicModal()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base">Cancel</button>
                <button onclick="saveEctopicInfo()" class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-base">Save</button>
            </div>
        </div>
    </div>

    <!-- User Guide Modal -->
    <div id="instructionsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-2xl max-w-5xl w-full max-h-[90vh] flex flex-col">
            <!-- Header -->
            <div class="flex justify-between items-center px-6 py-4 border-b border-gray-200 dark:border-gray-700">
                <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100">üìò User Guide</h2>
                <button onclick="closeInstructionsModal()" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-2xl w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">‚úï</button>
            </div>

            <!-- Tab Navigation -->
            <div class="flex border-b border-gray-200 dark:border-gray-700 px-6 bg-gray-50 dark:bg-gray-900">
                <button onclick="switchUserGuideTab('getting-started')" id="tab-getting-started" class="user-guide-tab px-4 py-3 font-medium text-sm border-b-2 border-primary text-primary">
                    Getting Started
                </button>
                <button onclick="switchUserGuideTab('features')" id="tab-features" class="user-guide-tab px-4 py-3 font-medium text-sm border-b-2 border-transparent text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200">
                    Features
                </button>
                <button onclick="switchUserGuideTab('keyboard-shortcuts')" id="tab-keyboard-shortcuts" class="user-guide-tab px-4 py-3 font-medium text-sm border-b-2 border-transparent text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200">
                    Keyboard Shortcuts
                </button>
            </div>

            <!-- Content Area -->
            <div class="flex-1 overflow-y-auto px-6 py-6">
                <!-- Getting Started Tab -->
                <div id="content-getting-started" class="user-guide-content space-y-6">
                    <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                        <p class="text-sm text-blue-900 dark:text-blue-100">
                            <strong>Welcome to Fast Family Tree Maker!</strong> This application helps you create professional pedigree charts for medical and genetic documentation. Use the tabs above to explore different sections of this guide.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚óè</span> Adding Symbols
                        </h3>
                        <div class="ml-6 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                            <p>‚Ä¢ <strong>Click & Place:</strong> Click a tool button in the toolbar, then click on the canvas where you want to place the symbol</p>
                            <p>‚Ä¢ <strong>Drag & Drop:</strong> Drag symbols directly from the toolbar onto the canvas for quick placement</p>
                            <p>‚Ä¢ <strong>Right-Click Menu:</strong> Right-click empty space on the canvas for a quick symbol placement menu</p>
                            <p>‚Ä¢ <strong>Auto-Snapping:</strong> Symbols automatically align to generation lines when placed to maintain proper alignment</p>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚óè</span> Creating Relationships
                        </h3>
                        <div class="ml-6 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                            <p>‚Ä¢ <strong>Marriage:</strong> Select 2 partners (by drag-selecting or with Marriage tool), then click the "Marriage" button to create a partnership line</p>
                            <p>‚Ä¢ <strong>Consanguineous:</strong> Select 2 blood relatives, then click "Consanguineous" to create a double-line connection</p>
                            <p>‚Ä¢ <strong>Adjusting Connections:</strong> Select a marriage or consanguineous line, then drag the middle handle to adjust the angle and length</p>
                            <p>‚Ä¢ <strong>Offspring:</strong> Select children on the same generation line, then click "Offspring" to connect them to their parents above</p>
                            <p>‚Ä¢ <strong>Family Connection:</strong> Select parents and children together, then click "Connect as Family" for automatic setup of both marriage and offspring relationships</p>
                            <p>‚Ä¢ <strong>Donors:</strong> Right-click pregnancy symbols to add egg or sperm donors with automatic connection lines</p>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚óè</span> Navigation & Selection
                        </h3>
                        <div class="ml-6 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                            <p>‚Ä¢ <strong>Move:</strong> Click and drag any symbol or selected group to reposition it on the canvas</p>
                            <p>‚Ä¢ <strong>Multi-Select:</strong> Drag on empty space to create a selection rectangle around multiple items</p>
                            <p>‚Ä¢ <strong>Add to Selection:</strong> Hold Ctrl and click items to add or remove them from the current selection</p>
                            <p>‚Ä¢ <strong>Select All:</strong> Press Ctrl+A to select all items on the canvas at once</p>
                            <p>‚Ä¢ <strong>Copy/Paste:</strong> Use Ctrl+C/Ctrl+V, toolbar buttons, or right-click menu to duplicate items</p>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚óè</span> Best Practices
                        </h3>
                        <div class="ml-6 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                            <p>‚Ä¢ Follow standard conventions: males on left, females on right, oldest to youngest from left to right</p>
                            <p>‚Ä¢ Use generation lines to keep family members properly aligned vertically</p>
                            <p>‚Ä¢ Save your work regularly using the Save Canvas (üíæ) button</p>
                            <p>‚Ä¢ Create disorder patterns in the legend before assigning them to individuals</p>
                            <p>‚Ä¢ Use text boxes for additional notes, dates, or clinical information</p>
                            <p>‚Ä¢ Test your saved files periodically to ensure they load correctly</p>
                        </div>
                    </div>
                </div>

                <!-- Features Tab -->
                <div id="content-features" class="user-guide-content hidden space-y-6">
                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚óè</span> Editing & Customization
                        </h3>
                        <div class="ml-6 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                            <p>‚Ä¢ <strong>Edit Details:</strong> Double-click any symbol or text box to open the edit dialog, or use the right-click context menu</p>
                            <p>‚Ä¢ <strong>Deceased Status:</strong> Use the Deceased tool to click symbols and toggle the diagonal slash indicator</p>
                            <p>‚Ä¢ <strong>Delete Items:</strong> Select items and press Delete or Backspace, click the Delete button, or use the right-click menu</p>
                            <p>‚Ä¢ <strong>Disorder Patterns:</strong> Create custom patterns in the legend panel, then assign them to specific quadrants of symbols when editing</p>
                            <p>‚Ä¢ <strong>Text Boxes:</strong> Add notes, labels, and clinical information anywhere on the canvas using text boxes</p>
                            <p>‚Ä¢ <strong>Resize Text Boxes:</strong> Click and drag the corner handles of any text box to resize it</p>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚óè</span> File Management & Export
                        </h3>
                        <div class="ml-6 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                            <p>‚Ä¢ <strong>Save Canvas (üíæ):</strong> Downloads your family tree as a JSON file that preserves all data including individuals, connections, text boxes, and disorder patterns. Use this to backup your work or share editable versions.</p>
                            <p>‚Ä¢ <strong>Load Canvas (    ):</strong> Opens a saved JSON file to restore a previously created family tree. All data including names, birth years, patterns, and relationships will be restored exactly as saved.</p>
                            <p>‚Ä¢ <strong>Download PDF (üìÑ):</strong> Creates a professional PDF document of your family tree with symbol legend and pattern definitions. Perfect for printing, sharing with medical professionals, or archiving.</p>
                            <p>‚Ä¢ <strong>File Compatibility:</strong> Save files (.json) are only compatible with this application. PDF files are universally readable but cannot be edited.</p>
                            <p>‚Ä¢ <strong>Backup Recommendations:</strong> Save your work regularly and keep multiple backup files, especially for complex family trees with extensive medical histories.</p>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚óè</span> Special Features
                        </h3>
                        <div class="ml-6 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                            <p>‚Ä¢ <strong>Auto-Snapping:</strong> Symbols automatically align to generation lines for consistent vertical positioning</p>
                            <p>‚Ä¢ <strong>Pattern System:</strong> Create custom disorder patterns with various fill styles in the legend, then apply them to any quadrant of a symbol</p>
                            <p>‚Ä¢ <strong>Group Operations:</strong> Select multiple items to perform batch operations like moving, copying, or deleting while preserving relationships</p>
                            <p>‚Ä¢ <strong>Relationship Preservation:</strong> When copying and pasting groups, all relationships between items are maintained</p>
                            <p>‚Ä¢ <strong>Undo/Redo:</strong> Press Ctrl+Z to undo your last action (up to 50 actions can be undone)</p>
                        </div>
                    </div>
                </div>

                <!-- Keyboard Shortcuts Tab -->
                <div id="content-keyboard-shortcuts" class="user-guide-content hidden space-y-6">
                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚å®Ô∏è</span> Keyboard Shortcuts
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-3">
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Copy selected items</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Ctrl+C</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Paste from clipboard</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Ctrl+V</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Select all items</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Ctrl+A</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Undo last action</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Ctrl+Z</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Delete selected items</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Delete</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Delete selected items</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Backspace</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Close modal/dialog</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Esc</kbd>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">üñ±Ô∏è</span> Mouse Interactions
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-3">
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Edit individual/text box</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Double-click</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Open context menu</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Right-click</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Multi-select rectangle</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Drag on empty</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Add to selection</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Ctrl+Click</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Move symbols/groups</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Click & Drag</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 px-3 rounded bg-gray-50 dark:bg-gray-800">
                                <span class="text-sm text-gray-700 dark:text-gray-300">Resize text box</span>
                                <kbd class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 px-3 py-1 rounded text-xs font-mono shadow-sm">Drag corners</kbd>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
                            <span class="text-primary mr-2">‚ö°</span> Quick Actions
                        </h3>
                        <div class="space-y-3">
                            <div class="py-3 px-4 rounded bg-gray-50 dark:bg-gray-800 border-l-4 border-primary">
                                <div class="font-medium text-sm text-gray-800 dark:text-gray-200 mb-1">Right-click on empty space</div>
                                <div class="text-sm text-gray-600 dark:text-gray-400">Quick symbol placement menu for adding individuals</div>
                            </div>
                            <div class="py-3 px-4 rounded bg-gray-50 dark:bg-gray-800 border-l-4 border-primary">
                                <div class="font-medium text-sm text-gray-800 dark:text-gray-200 mb-1">Right-click on individuals</div>
                                <div class="text-sm text-gray-600 dark:text-gray-400">Access edit, delete, copy, and other context options</div>
                            </div>
                            <div class="py-3 px-4 rounded bg-gray-50 dark:bg-gray-800 border-l-4 border-primary">
                                <div class="font-medium text-sm text-gray-800 dark:text-gray-200 mb-1">Right-click on pregnancy symbols</div>
                                <div class="text-sm text-gray-600 dark:text-gray-400">Add egg or sperm donors with automatic connection lines</div>
                            </div>
                            <div class="py-3 px-4 rounded bg-gray-50 dark:bg-gray-800 border-l-4 border-primary">
                                <div class="font-medium text-sm text-gray-800 dark:text-gray-200 mb-1">Drag from toolbar</div>
                                <div class="text-sm text-gray-600 dark:text-gray-400">Click and drag symbols from the toolbar directly onto the canvas for quick placement</div>
                            </div>
                            <div class="py-3 px-4 rounded bg-gray-50 dark:bg-gray-800 border-l-4 border-primary">
                                <div class="font-medium text-sm text-gray-800 dark:text-gray-200 mb-1">Family Connection button</div>
                                <div class="text-sm text-gray-600 dark:text-gray-400">Appears when valid family is selected ‚Ä¢ Creates marriage and offspring connections in one click</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div class="flex justify-between items-center px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900">
                <button onclick="downloadUserGuidePDF()" class="px-6 py-2 bg-green-600 text-white hover:bg-green-700 rounded-lg text-base font-medium transition-colors shadow-sm">
                    üìÑ Download Guide
                </button>
                <button onclick="closeInstructionsModal()" class="px-6 py-2 bg-primary-600 text-white hover:bg-primary-700 rounded-lg text-base font-medium transition-colors shadow-sm">
                    Close
                </button>
            </div>
        </div>
    </div>



    <!-- Feedback Notes Modal -->
    <div id="feedbackModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-2xl w-full mx-4 max-h-screen overflow-y-auto">
            <h3 class="text-lg font-semibold mb-3">üìù App Feedback Notes</h3>

            <!-- Instructions -->
            <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg">
                <p class="text-sm text-gray-700 dark:text-gray-300">
                    <strong>How to use:</strong> Keep notes during your session about bugs, feature requests, or improvements.
                    Click <strong>"Send Feedback"</strong> to open your email client with your notes already filled in, or copy your notes manually and email them to us at <strong class="text-blue-600 dark:text-blue-400 cursor-pointer hover:underline hover:text-blue-700 dark:hover:text-blue-300" onclick="emailFeedback()" title="Click to open email client with your notes">info@genescreen.ca</strong>.
                    Your notes cannot be saved, so please send them before you end your current session.
                </p>
            </div>

            <!-- Notes textarea -->
            <div class="mb-4">
                <label class="block text-sm font-medium mb-2">Your Notes:</label>
                <textarea
                    id="feedbackNotes"
                    rows="12"
                    class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base resize-y font-mono"
                    placeholder="Write your feedback here...&#10;&#10;Examples:&#10;- Bug: Undo button doesn't work after deleting connections&#10;- Feature request: Add zoom controls&#10;- Improvement: Make toolbar draggable on mobile"
                ></textarea>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col sm:flex-row gap-3 mb-4">
                <button onclick="emailFeedback()" class="flex-1 px-4 py-2 bg-purple-600 text-white hover:bg-purple-700 rounded text-base font-medium">
                    üì® Send Feedback
                </button>
                <button onclick="copyFeedbackNotes()" class="flex-1 px-4 py-2 bg-green-600 text-white hover:bg-green-700 rounded text-base font-medium">
                    üìã Copy Notes
                </button>
                <button onclick="copyDeveloperEmail()" class="flex-1 px-4 py-2 bg-blue-600 text-white hover:bg-blue-700 rounded text-base font-medium">
                    ‚úâÔ∏è Copy Our Email
                </button>
                <button onclick="clearFeedbackNotes()" class="flex-1 px-4 py-2 bg-orange-600 text-white hover:bg-orange-700 rounded text-base font-medium">
                    üóëÔ∏è Clear Notes
                </button>
            </div>

            <!-- Copy Status Message -->
            <div id="feedbackCopyStatus" class="mb-4 p-2 rounded text-sm text-center hidden"></div>

            <!-- Close Button -->
            <div class="flex justify-end">
                <button onclick="closeFeedbackModal()" class="px-4 py-2 bg-gray-600 text-white hover:bg-gray-700 rounded text-base">Close</button>
            </div>
        </div>
    </div>

    <!-- Individual Info Modal -->
    <div id="infoModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-sm w-full max-h-screen overflow-y-auto">
            <div class="p-6">
                <h3 class="text-lg font-semibold mb-4">Individual Information</h3>
                <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium mb-1">Name:</label>
                    <input type="text" id="individualName" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Birth Year:</label>
                    <input type="text" id="individualBirth" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Fill Character (single letter/digit):</label>
                    <input type="text" id="individualFillChar" maxlength="1" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="A, 1, X, etc.">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Sex Assignment at Birth:</label>
                    <select id="individualSexAtBirth" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                        <option value="">Select...</option>
                        <option value="AFAB">AFAB (Assigned Female at Birth)</option>
                        <option value="AMAB">AMAB (Assigned Male at Birth)</option>
                        <option value="unknown">Unknown</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Current Gender Identity:</label>
                    <select id="individualGenderIdentity" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                        <option value="">Select...</option>
                        <option value="male">Male</option>
                        <option value="female">Female</option>
                        <option value="non-binary">Non-binary</option>
                        <option value="unknown">Unknown</option>
                        <option value="other">Other</option>
                    </select>
                </div>

                <!-- Disorder Patterns -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                    <label class="block text-sm font-medium mb-2">Disorder Patterns by Quadrant:</label>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-xs mb-1">Top-Left:</label>
                            <select id="disorderTL" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                <option value="">None</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-xs mb-1">Top-Right:</label>
                            <select id="disorderTR" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                <option value="">None</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-xs mb-1">Bottom-Left:</label>
                            <select id="disorderBL" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                <option value="">None</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-xs mb-1">Bottom-Right:</label>
                            <select id="disorderBR" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                <option value="">None</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Notes:</label>
                    <textarea id="individualNotes" rows="3" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base"></textarea>
                </div>
                

                
                <!-- Display Options -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                    <label class="block text-sm font-medium mb-2">Display Options:</label>
                    <div class="space-y-2">
                        <label class="flex items-center">
                            <input type="checkbox" id="showName" class="mr-2">
                            <span class="text-sm">Show Name</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showBirth" class="mr-2">
                            <span class="text-sm">Show Birth Year</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showSexAtBirth" class="mr-2">
                            <span class="text-sm">Show Sex Assignment at Birth</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showGenderIdentity" class="mr-2">
                            <span class="text-sm">Show Gender Identity</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="showNotes" class="mr-2">
                            <span class="text-sm">Show Notes</span>
                        </label>
                    </div>
                </div>
                </div>
                <div class="flex justify-end space-x-3 mt-6">
                    <button onclick="closeInfoModal()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base">Cancel</button>
                    <button onclick="saveIndividualInfo()" class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-base">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Dark mode setup
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Canvas setup
        const canvas = document.getElementById('pedigreeCanvas');
        const ctx = canvas.getContext('2d');
        
        // SeparationSymbol class
        class SeparationSymbol {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.selected = false;
                this.length = 20; // Length of each slash (half the original size)
                this.spacing = 4; // Spacing between the two slashes (proportionally smaller)
                this.angle = -Math.PI / 4; // -45 degrees (southeast direction for forward slashes)
            }

            draw(ctx) {
                const isDark = document.documentElement.classList.contains('dark');
                ctx.strokeStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                ctx.lineWidth = this.selected ? 4 : 3;

                // Calculate the offset for parallel lines
                const perpAngle = this.angle + Math.PI / 2; // Perpendicular to main angle
                const offsetX = Math.cos(perpAngle) * this.spacing / 2;
                const offsetY = Math.sin(perpAngle) * this.spacing / 2;

                // Draw first slash
                const start1X = this.x - Math.cos(this.angle) * this.length / 2 + offsetX;
                const start1Y = this.y - Math.sin(this.angle) * this.length / 2 + offsetY;
                const end1X = this.x + Math.cos(this.angle) * this.length / 2 + offsetX;
                const end1Y = this.y + Math.sin(this.angle) * this.length / 2 + offsetY;

                ctx.beginPath();
                ctx.moveTo(start1X, start1Y);
                ctx.lineTo(end1X, end1Y);
                ctx.stroke();

                // Draw second slash
                const start2X = this.x - Math.cos(this.angle) * this.length / 2 - offsetX;
                const start2Y = this.y - Math.sin(this.angle) * this.length / 2 - offsetY;
                const end2X = this.x + Math.cos(this.angle) * this.length / 2 - offsetX;
                const end2Y = this.y + Math.sin(this.angle) * this.length / 2 - offsetY;

                ctx.beginPath();
                ctx.moveTo(start2X, start2Y);
                ctx.lineTo(end2X, end2Y);
                ctx.stroke();
            }

            contains(x, y) {
                // Check if point is near either of the two slash lines
                const perpAngle = this.angle + Math.PI / 2;
                const offsetX = Math.cos(perpAngle) * this.spacing / 2;
                const offsetY = Math.sin(perpAngle) * this.spacing / 2;

                // First slash endpoints
                const start1X = this.x - Math.cos(this.angle) * this.length / 2 + offsetX;
                const start1Y = this.y - Math.sin(this.angle) * this.length / 2 + offsetY;
                const end1X = this.x + Math.cos(this.angle) * this.length / 2 + offsetX;
                const end1Y = this.y + Math.sin(this.angle) * this.length / 2 + offsetY;

                // Second slash endpoints
                const start2X = this.x - Math.cos(this.angle) * this.length / 2 - offsetX;
                const start2Y = this.y - Math.sin(this.angle) * this.length / 2 - offsetY;
                const end2X = this.x + Math.cos(this.angle) * this.length / 2 - offsetX;
                const end2Y = this.y + Math.sin(this.angle) * this.length / 2 - offsetY;

                // Check distance to either line
                const dist1 = this.distanceToLine(x, y, start1X, start1Y, end1X, end1Y);
                const dist2 = this.distanceToLine(x, y, start2X, start2Y, end2X, end2Y);

                return Math.min(dist1, dist2) <= 8; // 8 pixel tolerance
            }

            distanceToLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // App state
        let currentTool = null;
        let individuals = [];

        let textBoxes = [];  // Array to store text boxes
        let probandArrows = [];  // Array to store proband arrows
        let separationSymbols = [];  // Array to store separation symbols
        let selectedItem = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let connectingFrom = null;
        let currentIndividualId = null;
        let currentTextBoxId = null;  // For text box editing
        
        // Symbol dragging state
        let isDraggingSymbol = false;
        let draggedSymbolType = null;
        let dragPreview = null;
        
        // Text box resizing state
        let isResizing = false;
        let resizeHandle = null;
        let resizeStartPos = { x: 0, y: 0 };
        let resizeStartSize = { width: 0, height: 0, maxWidth: 0 };
        
        // Undo system
        let undoHistory = [];
        let maxHistorySize = 100; // Limit to prevent memory issues
        
        // Group selection state
        let isGroupSelecting = false;
        let groupSelectStart = { x: 0, y: 0 };
        let groupSelectEnd = { x: 0, y: 0 };
        let selectedIndividuals = [];
        let isAdditiveSelection = false;
        let hasDragged = false;
        
        // Group dragging state
        let isGroupDragging = false;
        let groupDragOffsets = [];

        // Connection dragging state
        let isDraggingConnection = false;
        let draggedConnection = null;
        let connectionDragStartY = 0;

        // Copy/paste clipboard state
        let clipboard = {
            individuals: [],
            connections: [],
            textBoxes: []
        };

        // Symbol size (increased by 20% total)
        const SYMBOL_SIZE = 40;
        const SYMBOL_RADIUS = SYMBOL_SIZE / 2;
        const MISCARRIAGE_RADIUS = Math.round(SYMBOL_RADIUS * 2/3); // Miscarriage symbols are 2/3 the size
        
        // Snap lines configuration (grid spacing kept original)
        const SNAP_LINES = [150, 300, 450, 600]; // Y coordinates for 4 horizontal snap lines
        const SNAP_THRESHOLD = 28; // Distance threshold for snapping (increased by 10%)

        // Initialize symbol previews
        function initSymbolPreviews() {
            const previews = document.querySelectorAll('.symbol-preview');
            previews.forEach((canvas, index) => {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 24, 24);
                
                const isDark = document.documentElement.classList.contains('dark');
                ctx.strokeStyle = isDark ? '#ffffff' : '#000000';
                ctx.fillStyle = isDark ? '#ffffff' : '#000000';
                ctx.lineWidth = 2;

                switch (index) {
                    case 0: // Male
                        ctx.strokeRect(4, 4, 16, 16);
                        break;
                    case 1: // Female  
                        ctx.beginPath();
                        ctx.arc(12, 12, 8, 0, 2 * Math.PI);
                        ctx.stroke();
                        break;
                    case 2: // Unknown
                        ctx.beginPath();
                        ctx.moveTo(12, 4);
                        ctx.lineTo(20, 12);
                        ctx.lineTo(12, 20);
                        ctx.lineTo(4, 12);
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 3: // Proband Arrow
                        // Draw arrow pointing northeast
                        const startX = 4, startY = 20;
                        const endX = 20, endY = 4;
                        
                        // Draw arrow shaft
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        
                        // Draw arrowhead
                        const arrowHeadLength = 6;
                        const angle = Math.atan2(endY - startY, endX - startX);
                        const arrowHeadAngle = Math.PI / 6; // 30 degrees
                        
                        // Left side of arrowhead
                        const leftHeadX = endX - arrowHeadLength * Math.cos(angle - arrowHeadAngle);
                        const leftHeadY = endY - arrowHeadLength * Math.sin(angle - arrowHeadAngle);
                        
                        // Right side of arrowhead
                        const rightHeadX = endX - arrowHeadLength * Math.cos(angle + arrowHeadAngle);
                        const rightHeadY = endY - arrowHeadLength * Math.sin(angle + arrowHeadAngle);
                        
                        // Draw arrowhead as a filled triangle
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(leftHeadX, leftHeadY);
                        ctx.lineTo(rightHeadX, rightHeadY);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 4: // Pregnancy
                        ctx.beginPath();
                        ctx.moveTo(12, 4);
                        ctx.lineTo(20, 12);
                        ctx.lineTo(12, 20);
                        ctx.lineTo(4, 12);
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Draw the "P" inside the diamond
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('P', 12, 12);
                        break;
                    case 5: // Miscarriage
                        ctx.beginPath();
                        ctx.moveTo(12, 4);  // Top point
                        ctx.lineTo(20, 20); // Bottom right
                        ctx.lineTo(4, 20);  // Bottom left
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 6: // TAB
                        ctx.beginPath();
                        ctx.moveTo(12, 4);  // Top point
                        ctx.lineTo(20, 20); // Bottom right
                        ctx.lineTo(4, 20);  // Bottom left
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Draw the deceased slash
                        ctx.beginPath();
                        ctx.moveTo(4 - 2, 20 + 2); // Bottom left with extension
                        ctx.lineTo(20 + 2, 4 - 2); // Top right with extension
                        ctx.stroke();
                        break;
                    case 7: // Ectopic
                        ctx.beginPath();
                        ctx.arc(12, 12, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                    case 8: // Legend Male
                        ctx.strokeRect(2, 2, 16, 16);
                        break;
                    case 9: // Legend Female
                        ctx.beginPath();
                        ctx.arc(10, 10, 8, 0, 2 * Math.PI);
                        ctx.stroke();
                        break;
                    case 10: // Legend Unknown
                        ctx.beginPath();
                        ctx.moveTo(10, 2);
                        ctx.lineTo(18, 10);
                        ctx.lineTo(10, 18);
                        ctx.lineTo(2, 10);
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 11: // Legend Affected
                        ctx.beginPath();
                        ctx.arc(10, 10, 8, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                    case 12: // Legend Miscarriage
                        ctx.beginPath();
                        ctx.moveTo(10, 2);  // Top point
                        ctx.lineTo(18, 18); // Bottom right
                        ctx.lineTo(2, 18);  // Bottom left
                        ctx.closePath();
                        ctx.stroke();
                        break;
                }
            });
        }

        // Tool selection with toggle functionality
        function setTool(tool) {
            const toolButton = document.getElementById(`btn-${tool}`);
            
            // Check if the tool is already selected - if so, deselect it
            if (currentTool === tool && toolButton && toolButton.classList.contains('selected-symbol')) {
                // Deselect the current tool - no tool selected
                currentTool = null;
                document.querySelectorAll('button[id^="btn-"]').forEach(btn => {
                    btn.classList.remove('selected-symbol');
                });
                
                // Reset canvas cursor
                canvas.style.cursor = 'default';
                return;
            }
            
            // Select the new tool
            currentTool = tool;
            document.querySelectorAll('button[id^="btn-"]').forEach(btn => {
                btn.classList.remove('selected-symbol');
            });
            
            if (toolButton) {
                toolButton.classList.add('selected-symbol');
            }
            
            // Update cursor based on tool
            canvas.style.cursor = tool === 'select' ? 'default' : 'crosshair';
        }

        // Event listeners for tools
        document.getElementById('btn-male').addEventListener('click', () => setTool('male'));
        document.getElementById('btn-female').addEventListener('click', () => setTool('female'));
        document.getElementById('btn-unknown').addEventListener('click', () => setTool('unknown'));
        document.getElementById('btn-miscarriage').addEventListener('click', () => setTool('miscarriage'));
        document.getElementById('btn-pregnancy').addEventListener('click', () => setTool('pregnancy'));
        document.getElementById('btn-ectopic').addEventListener('click', () => setTool('ectopic'));
        document.getElementById('btn-tab').addEventListener('click', () => setTool('tab'));
        document.getElementById('btn-proband').addEventListener('click', () => setTool('proband'));

        // Add drag functionality to symbol buttons
        initSymbolDragAndDrop();

        // Make tools panel draggable
        initToolsPanelDrag();

        document.getElementById('btn-deceased').addEventListener('click', () => setTool('deceased'));
        document.getElementById('btn-separated').addEventListener('click', () => setTool('separated'));
        const textboxBtn = document.getElementById('btn-textbox');
        if (textboxBtn) {
            textboxBtn.addEventListener('click', () => setTool('textbox'));
        }
        document.getElementById('btn-undo').addEventListener('click', undoLastAction);
        document.getElementById('btn-delete').addEventListener('click', deleteSelected);
        document.getElementById('btn-copy').addEventListener('click', copySelected);
        document.getElementById('btn-paste').addEventListener('click', pasteClipboard);
        document.getElementById('btn-clear').addEventListener('click', clearAll);
        document.getElementById('btn-save').addEventListener('click', saveCanvas);
        document.getElementById('btn-load').addEventListener('click', loadCanvas);
        document.getElementById('btn-download').addEventListener('click', downloadPDF);
        document.getElementById('btn-connect-family').addEventListener('click', connectSelectedAsFamily);
        document.getElementById('btn-marriage').addEventListener('click', connectSelectedAsMarriage);
        document.getElementById('btn-consanguineous').addEventListener('click', connectSelectedAsConsanguineous);
        document.getElementById('btn-identical').addEventListener('click', connectSelectedAsIdentical);
        document.getElementById('btn-siblings').addEventListener('click', connectSelectedAsSiblings);
        document.getElementById('btn-multiples').addEventListener('click', connectSelectedAsMultiples);

        document.getElementById('btn-feedback').addEventListener('click', openFeedbackModal);
        document.getElementById('btn-jump-instructions').addEventListener('click', openInstructionsModal);


        // Individual class
        class Individual {
            constructor(x, y, type, id) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = id;
                this.name = '';
                this.birth = '';
                this.notes = '';
                this.fillChar = '';
                this.showName = false;
                this.showBirth = false;
                this.showNotes = false;
                this.patternTL = '';  // Top-left quadrant pattern type
                this.patternTR = '';  // Top-right quadrant pattern type
                this.patternBL = '';  // Bottom-left quadrant pattern type
                this.patternBR = '';  // Bottom-right quadrant pattern type
                this.disorderTL = '';  // Top-left disorder name
                this.disorderTR = '';  // Top-right disorder name
                this.disorderBL = '';  // Bottom-left disorder name
                this.disorderBR = '';  // Bottom-right disorder name
                this.selected = false;
                this.deceased = false;
                // Unknown individual specific fields
                this.sexAtBirth = '';  // AFAB, AMAB, other
                this.genderIdentity = '';  // male, female, non-binary, other
                this.comments = '';  // Comments for unknown individuals
                this.showSexAtBirth = false;
                this.showGenderIdentity = false;
                this.showComments = false;
                // Pregnancy-specific fields
                this.lmp = '';  // Last Menstrual Period
                this.edc = '';  // Expected Date of Confinement
                this.showPregnancyNotes = false;  // Whether to show pregnancy notes
                // Maternal complications
                this.maternalHypertension = false;
                this.maternalPreeclampsia = false;
                this.maternalGestationalDiabetes = false;
                this.maternalIDDM = false;
                this.maternalTeratogenicExposure = false;
                this.maternalPlacentalBleeding = false;
                this.maternalOther = false;
                this.showMaternalComplications = false;
                // Fetal complications
                this.fetalIUGR = false;
                this.fetalPosNIPT = false;
                this.fetalOligoPolyHydramnios = false;
                this.fetal3VesselCord = false;
                this.fetalSoftSignsUS = false;
                this.fetalOther = false;
                this.showFetalComplications = false;
            }

            draw(ctx) {
                const isDark = document.documentElement.classList.contains('dark');
                ctx.strokeStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                ctx.fillStyle = isDark ? '#ffffff' : '#000000';
                ctx.lineWidth = this.selected ? 3 : 2;

                switch (this.type) {
                    case 'male':
                        ctx.strokeRect(this.x - SYMBOL_RADIUS, this.y - SYMBOL_RADIUS, SYMBOL_SIZE, SYMBOL_SIZE);
                        break;
                    case 'female':
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, SYMBOL_RADIUS, 0, 2 * Math.PI);
                        ctx.stroke();
                        break;
                    case 'unknown':
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - SYMBOL_RADIUS);
                        ctx.lineTo(this.x + SYMBOL_RADIUS, this.y);
                        ctx.lineTo(this.x, this.y + SYMBOL_RADIUS);
                        ctx.lineTo(this.x - SYMBOL_RADIUS, this.y);
                        ctx.closePath();
                        ctx.stroke();
                        break;

                    case 'miscarriage':
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - MISCARRIAGE_RADIUS);      // Top point
                        ctx.lineTo(this.x + MISCARRIAGE_RADIUS, this.y + MISCARRIAGE_RADIUS); // Bottom right
                        ctx.lineTo(this.x - MISCARRIAGE_RADIUS, this.y + MISCARRIAGE_RADIUS); // Bottom left
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'pregnancy':
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - SYMBOL_RADIUS);
                        ctx.lineTo(this.x + SYMBOL_RADIUS, this.y);
                        ctx.lineTo(this.x, this.y + SYMBOL_RADIUS);
                        ctx.lineTo(this.x - SYMBOL_RADIUS, this.y);
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Draw the "P" inside the diamond (text size increased by 10%)
                        ctx.fillStyle = isDark ? '#ffffff' : '#000000';
                        ctx.font = 'bold 15px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('P', this.x, this.y);
                        break;
                    case 'ectopic':
                        // Draw a small filled circle (radius 6 instead of 15)
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                    case 'tab':
                        // Draw triangle like miscarriage
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - MISCARRIAGE_RADIUS);      // Top point
                        ctx.lineTo(this.x + MISCARRIAGE_RADIUS, this.y + MISCARRIAGE_RADIUS); // Bottom right
                        ctx.lineTo(this.x - MISCARRIAGE_RADIUS, this.y + MISCARRIAGE_RADIUS); // Bottom left
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Draw deceased slash through the triangle
                        ctx.strokeStyle = isDark ? '#ffffff' : '#000000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        // Extend the slash just beyond the triangle edges
                        const extension = 3;
                        ctx.moveTo(this.x - MISCARRIAGE_RADIUS - extension, this.y + MISCARRIAGE_RADIUS + extension);
                        ctx.lineTo(this.x + MISCARRIAGE_RADIUS + extension, this.y - MISCARRIAGE_RADIUS - extension);
                        ctx.stroke();
                        break;
                }

                // Draw quadrant patterns if any are set
                if (this.patternTL || this.patternTR || this.patternBL || this.patternBR) {
                    this.drawQuadrantPatterns(ctx, isDark);
                }

                // Draw deceased slash if applicable
                if (this.deceased) {
                    ctx.strokeStyle = isDark ? '#ffffff' : '#000000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Extend the slash beyond the symbol edges on both sides
                    const extension = 5;
                    ctx.moveTo(this.x - SYMBOL_RADIUS - extension, this.y + SYMBOL_RADIUS + extension);
                    ctx.lineTo(this.x + SYMBOL_RADIUS + extension, this.y - SYMBOL_RADIUS - extension);
                    ctx.stroke();
                }

                // Draw fill character if available (inside the symbol) (text size increased by 10%)
                if (this.fillChar) {
                    ctx.fillStyle = isDark ? '#ffffff' : '#000000';
                    ctx.font = 'bold 15px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.fillChar, this.x, this.y);
                }

                // Draw condensed information below symbol if enabled (sizes increased by 10%)
                let yOffset = SYMBOL_RADIUS + 13;
                const lineHeight = 12;
                
                ctx.fillStyle = isDark ? '#ffffff' : '#000000';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // Show name if enabled
                if (this.showName && this.name) {
                    ctx.fillText(this.name, this.x, this.y + yOffset);
                    yOffset += lineHeight;
                }
                
                // Show birth year if enabled
                if (this.showBirth && this.birth) {
                    ctx.fillText(`b.${this.birth}`, this.x, this.y + yOffset);
                    yOffset += lineHeight;
                }
                
                // Show unknown individual specific fields if enabled
                if (this.type === 'unknown') {
                    // Show sex assignment at birth if enabled
                    if (this.showSexAtBirth && this.sexAtBirth) {
                        ctx.fillText(`Sex at birth: ${this.sexAtBirth}`, this.x, this.y + yOffset);
                        yOffset += lineHeight;
                    }
                    
                    // Show gender identity if enabled
                    if (this.showGenderIdentity && this.genderIdentity) {
                        ctx.fillText(`Gender identity: ${this.genderIdentity}`, this.x, this.y + yOffset);
                        yOffset += lineHeight;
                    }
                    
                    // Show comments if enabled (truncate if too long)
                    if (this.showComments && this.comments) {
                        let displayComments = this.comments;
                        if (displayComments.length > 15) {
                            displayComments = displayComments.substring(0, 12) + '...';
                        }
                        ctx.fillText(displayComments, this.x, this.y + yOffset);
                        yOffset += lineHeight;
                    }
                } else {
                    // Show notes if enabled for regular individuals (truncate if too long)
                    if (this.showNotes && this.notes) {
                        let displayNotes = this.notes;
                        if (displayNotes.length > 15) {
                            displayNotes = displayNotes.substring(0, 12) + '...';
                        }
                        ctx.fillText(displayNotes, this.x, this.y + yOffset);
                        yOffset += lineHeight;
                    }
                }
                
                // Show pregnancy-specific information below symbol
                if (this.type === 'pregnancy') {
                    // Check if we have any pregnancy info to display
                    const hasPregnancyInfo = this.lmp || this.edc || (this.showPregnancyNotes && this.notes);
                    const hasRegularInfo = this.showName || this.showBirth || this.showNotes;
                    
                    // Add extra spacing between regular info and pregnancy info if both exist
                    if (hasPregnancyInfo && hasRegularInfo) {
                        yOffset += lineHeight;
                    }
                    
                    if (this.lmp) {
                        ctx.fillText(`LMP: ${this.lmp}`, this.x, this.y + yOffset);
                        yOffset += lineHeight;
                    }
                    
                    if (this.edc) {
                        ctx.fillText(`EDC: ${this.edc}`, this.x, this.y + yOffset);
                        yOffset += lineHeight;
                    }
                    
                    // Show pregnancy notes if enabled (truncate if too long)
                    if (this.showPregnancyNotes && this.notes) {
                        let displayNotes = this.notes;
                        if (displayNotes.length > 15) {
                            displayNotes = displayNotes.substring(0, 12) + '...';
                        }
                        ctx.fillText(`Notes: ${displayNotes}`, this.x, this.y + yOffset);
                        yOffset += lineHeight;
                    }
                    
                    // Show maternal complications if enabled
                    if (this.showMaternalComplications) {
                        const maternalComps = [];
                        if (this.maternalHypertension) maternalComps.push('HTN');
                        if (this.maternalPreeclampsia) maternalComps.push('Preeclampsia');
                        if (this.maternalGestationalDiabetes) maternalComps.push('GDM');
                        if (this.maternalIDDM) maternalComps.push('IDDM');
                        if (this.maternalTeratogenicExposure) maternalComps.push('Teratogenic');
                        if (this.maternalPlacentalBleeding) maternalComps.push('Bleeding');
                        if (this.maternalOther) maternalComps.push('Other');
                        
                        if (maternalComps.length > 0) {
                            let displayComps = maternalComps.join(', ');
                            if (displayComps.length > 20) {
                                displayComps = displayComps.substring(0, 17) + '...';
                            }
                            ctx.fillText(`Mat: ${displayComps}`, this.x, this.y + yOffset);
                            yOffset += lineHeight;
                        }
                    }
                    
                    // Show fetal complications if enabled
                    if (this.showFetalComplications) {
                        const fetalComps = [];
                        if (this.fetalIUGR) fetalComps.push('IUGR');
                        if (this.fetalPosNIPT) fetalComps.push('POS NIPT');
                        if (this.fetalOligoPolyHydramnios) fetalComps.push('Oligo/Poly');
                        if (this.fetal3VesselCord) fetalComps.push('3 Vessel');
                        if (this.fetalSoftSignsUS) fetalComps.push('Soft Signs');
                        if (this.fetalOther) fetalComps.push('Other');
                        
                        if (fetalComps.length > 0) {
                            let displayComps = fetalComps.join(', ');
                            if (displayComps.length > 20) {
                                displayComps = displayComps.substring(0, 17) + '...';
                            }
                            ctx.fillText(`Fetal: ${displayComps}`, this.x, this.y + yOffset);
                            yOffset += lineHeight;
                        }
                    }
                }
                
                // Show miscarriage-specific information below symbol
                if (this.type === 'miscarriage') {
                    if ((this.showMiscarriageGestation && this.weeksGestation) || 
                        (this.showFetalAnomalies && this.fetalAnomalies) || 
                        (this.showMiscarriageComments && this.miscarriageComments)) {
                        
                        if (this.showName || this.showBirth || this.showNotes) {
                            yOffset += lineHeight; // Add extra spacing between regular info and miscarriage info
                        }
                        
                        if (this.showMiscarriageGestation && this.weeksGestation) {
                            ctx.fillText(`${this.weeksGestation}w`, this.x, this.y + yOffset);
                            yOffset += lineHeight;
                        }
                        
                        if (this.showFetalAnomalies && this.fetalAnomalies) {
                            let displayAnomalies = this.fetalAnomalies;
                            // Convert anomaly values to more readable display text
                            switch(this.fetalAnomalies) {
                                case 'yes': displayAnomalies = 'Anomalies: Yes'; break;
                                case 'no': displayAnomalies = 'Anomalies: No'; break;
                                case 'unknown': displayAnomalies = 'Anomalies: Unknown'; break;
                            }
                            ctx.fillText(displayAnomalies, this.x, this.y + yOffset);
                            yOffset += lineHeight;
                        }
                        
                        if (this.showMiscarriageComments && this.miscarriageComments) {
                            let displayComments = this.miscarriageComments;
                            if (displayComments.length > 15) {
                                displayComments = displayComments.substring(0, 12) + '...';
                            }
                            ctx.fillText(displayComments, this.x, this.y + yOffset);
                            yOffset += lineHeight;
                        }
                    }
                }
                
                // Show TAB-specific information below symbol
                if (this.type === 'tab') {
                    if ((this.showGestation && this.gestation) || (this.showReason && this.reason) || (this.showComments && this.comments)) {
                        if (this.showName || this.showBirth || this.showNotes) {
                            yOffset += lineHeight; // Add extra spacing between regular info and TAB info
                        }
                        
                        if (this.showGestation && this.gestation) {
                            ctx.fillText(`${this.gestation}w`, this.x, this.y + yOffset);
                            yOffset += lineHeight;
                        }
                        
                        if (this.showReason && this.reason) {
                            let displayReason = this.reason;
                            // Convert reason values to more readable display text
                            switch(this.reason) {
                                case 'maternal-health': displayReason = 'Mat health'; break;
                                case 'fetal-abnormality': displayReason = 'Fetal abn'; break;
                                case 'genetic-disorder': displayReason = 'Genetic'; break;
                                case 'personal-choice': displayReason = 'Personal'; break;
                                case 'other': displayReason = 'Other'; break;
                            }
                            ctx.fillText(displayReason, this.x, this.y + yOffset);
                            yOffset += lineHeight;
                        }
                        
                        if (this.showComments && this.comments) {
                            let displayComments = this.comments;
                            if (displayComments.length > 15) {
                                displayComments = displayComments.substring(0, 12) + '...';
                            }
                            ctx.fillText(displayComments, this.x, this.y + yOffset);
                            yOffset += lineHeight;
                        }
                    }
                }
                
                // Show "ectopic" label below ectopic pregnancy symbols
                if (this.type === 'ectopic') {
                    ctx.fillText('ectopic', this.x, this.y + yOffset);
                    yOffset += lineHeight;
                }
            }

            drawQuadrantPatterns(ctx, isDark) {
                // Draw each quadrant pattern with individual clipping
                const patterns = [
                    { pattern: this.patternTL, quadrant: 'TL' },
                    { pattern: this.patternTR, quadrant: 'TR' },
                    { pattern: this.patternBL, quadrant: 'BL' },
                    { pattern: this.patternBR, quadrant: 'BR' }
                ];
                
                patterns.forEach(({ pattern, quadrant }) => {
                    if (pattern) {
                        ctx.save();
                        this.setQuadrantClip(ctx, quadrant);
                        this.drawPattern(ctx, pattern, quadrant, isDark);
                        ctx.restore();
                    }
                });
            }
            
            setQuadrantClip(ctx, quadrant) {
                // Define quadrant boundaries
                let x1, y1, x2, y2;
                switch (quadrant) {
                    case 'TL': // Top-left
                        x1 = this.x - SYMBOL_RADIUS; y1 = this.y - SYMBOL_RADIUS;
                        x2 = this.x; y2 = this.y;
                        break;
                    case 'TR': // Top-right
                        x1 = this.x; y1 = this.y - SYMBOL_RADIUS;
                        x2 = this.x + SYMBOL_RADIUS; y2 = this.y;
                        break;
                    case 'BL': // Bottom-left
                        x1 = this.x - SYMBOL_RADIUS; y1 = this.y;
                        x2 = this.x; y2 = this.y + SYMBOL_RADIUS;
                        break;
                    case 'BR': // Bottom-right
                        x1 = this.x; y1 = this.y;
                        x2 = this.x + SYMBOL_RADIUS; y2 = this.y + SYMBOL_RADIUS;
                        break;
                }
                
                // Create clipping path that combines the quadrant rectangle with the symbol shape
                ctx.beginPath();
                
                // Start with the symbol shape
                switch (this.type) {
                    case 'male':
                        ctx.rect(this.x - SYMBOL_RADIUS, this.y - SYMBOL_RADIUS, SYMBOL_SIZE, SYMBOL_SIZE);
                        break;
                    case 'female':
                        ctx.arc(this.x, this.y, SYMBOL_RADIUS, 0, 2 * Math.PI);
                        break;
                    case 'unknown':
                        ctx.moveTo(this.x, this.y - SYMBOL_RADIUS);
                        ctx.lineTo(this.x + SYMBOL_RADIUS, this.y);
                        ctx.lineTo(this.x, this.y + SYMBOL_RADIUS);
                        ctx.lineTo(this.x - SYMBOL_RADIUS, this.y);
                        ctx.closePath();
                        break;
                    case 'miscarriage':
                        ctx.moveTo(this.x, this.y - SYMBOL_RADIUS);
                        ctx.lineTo(this.x + SYMBOL_RADIUS, this.y + SYMBOL_RADIUS);
                        ctx.lineTo(this.x - SYMBOL_RADIUS, this.y + SYMBOL_RADIUS);
                        ctx.closePath();
                        break;
                    case 'pregnancy':
                        ctx.moveTo(this.x, this.y - SYMBOL_RADIUS);
                        ctx.lineTo(this.x + SYMBOL_RADIUS, this.y);
                        ctx.lineTo(this.x, this.y + SYMBOL_RADIUS);
                        ctx.lineTo(this.x - SYMBOL_RADIUS, this.y);
                        ctx.closePath();
                        break;
                }
                ctx.clip();
                
                // Then clip to the quadrant rectangle
                ctx.beginPath();
                ctx.rect(x1, y1, x2 - x1, y2 - y1);
                ctx.clip();
            }
            
            drawPattern(ctx, pattern, quadrant, isDark) {
                // Define quadrant boundaries
                let x1, y1, x2, y2;
                switch (quadrant) {
                    case 'TL': // Top-left
                        x1 = this.x - SYMBOL_RADIUS; y1 = this.y - SYMBOL_RADIUS;
                        x2 = this.x; y2 = this.y;
                        break;
                    case 'TR': // Top-right
                        x1 = this.x; y1 = this.y - SYMBOL_RADIUS;
                        x2 = this.x + SYMBOL_RADIUS; y2 = this.y;
                        break;
                    case 'BL': // Bottom-left
                        x1 = this.x - SYMBOL_RADIUS; y1 = this.y;
                        x2 = this.x; y2 = this.y + SYMBOL_RADIUS;
                        break;
                    case 'BR': // Bottom-right
                        x1 = this.x; y1 = this.y;
                        x2 = this.x + SYMBOL_RADIUS; y2 = this.y + SYMBOL_RADIUS;
                        break;
                }
                
                ctx.fillStyle = isDark ? '#ffffff' : '#000000';
                ctx.strokeStyle = isDark ? '#ffffff' : '#000000';
                ctx.lineWidth = 1;
                
                switch (pattern) {
                    case 'solid':
                        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                        break;
                        
                    case 'diagonal1': // \ lines
                        const width1 = x2 - x1;
                        const height1 = y2 - y1;
                        const diagonal1Length = Math.sqrt(width1 * width1 + height1 * height1);

                        for (let i = -height1; i <= width1 + height1; i += 6) {
                            ctx.beginPath();
                            ctx.moveTo(x1 + i, y1);
                            ctx.lineTo(x1 + i + height1, y2);
                            ctx.stroke();
                        }
                        break;

                    case 'horizontal':
                        for (let y = y1; y <= y2; y += 6) {
                            ctx.beginPath();
                            ctx.moveTo(x1, y);
                            ctx.lineTo(x2, y);
                            ctx.stroke();
                        }
                        break;

                    case 'vertical':
                        for (let x = x1; x <= x2; x += 6) {
                            ctx.beginPath();
                            ctx.moveTo(x, y1);
                            ctx.lineTo(x, y2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'dots':
                        for (let x = x1 + 2; x < x2; x += 4) {
                            for (let y = y1 + 2; y < y2; y += 4) {
                                ctx.beginPath();
                                ctx.arc(x, y, 0.5, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                        break;
                        
                    case 'crosshatch':
                        // Draw both diagonal patterns
                        for (let i = -SYMBOL_SIZE; i <= SYMBOL_SIZE; i += 6) {
                            ctx.beginPath();
                            ctx.moveTo(x1 + i, y1);
                            ctx.lineTo(x2 + i, y2);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(x1 + i, y2);
                            ctx.lineTo(x2 + i, y1);
                            ctx.stroke();
                        }
                        break;
                }
            }

            contains(x, y) {
                switch (this.type) {
                    case 'male':
                        // Rectangle hit detection
                        return x >= this.x - SYMBOL_RADIUS && x <= this.x + SYMBOL_RADIUS &&
                               y >= this.y - SYMBOL_RADIUS && y <= this.y + SYMBOL_RADIUS;
                    
                    case 'female':
                        // Circle hit detection
                        return Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2) <= SYMBOL_RADIUS;
                    
                    case 'unknown':
                    case 'pregnancy':
                        // Diamond hit detection - check if point is inside diamond
                        const dx = Math.abs(x - this.x);
                        const dy = Math.abs(y - this.y);
                        return (dx / SYMBOL_RADIUS + dy / SYMBOL_RADIUS) <= 1;
                    
                    case 'miscarriage':
                    case 'tab':
                        // Triangle hit detection - check if point is inside triangle
                        // Triangle points: top (x, y-SYMBOL_RADIUS), bottom-left (x-SYMBOL_RADIUS, y+SYMBOL_RADIUS), bottom-right (x+SYMBOL_RADIUS, y+SYMBOL_RADIUS)
                        const topX = this.x;
                        const topY = this.y - SYMBOL_RADIUS;
                        const bottomLeftX = this.x - SYMBOL_RADIUS;
                        const bottomLeftY = this.y + SYMBOL_RADIUS;
                        const bottomRightX = this.x + SYMBOL_RADIUS;
                        const bottomRightY = this.y + SYMBOL_RADIUS;
                        
                        // Use barycentric coordinates to check if point is inside triangle
                        const denom = (bottomLeftY - bottomRightY) * (topX - bottomRightX) + (bottomRightX - bottomLeftX) * (topY - bottomRightY);
                        const a = ((bottomLeftY - bottomRightY) * (x - bottomRightX) + (bottomRightX - bottomLeftX) * (y - bottomRightY)) / denom;
                        const b = ((bottomRightY - topY) * (x - bottomRightX) + (topX - bottomRightX) * (y - bottomRightY)) / denom;
                        const c = 1 - a - b;
                        
                        return a >= 0 && b >= 0 && c >= 0;
                    
                    case 'ectopic':
                        // Small circle hit detection
                        return Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2) <= 6;
                    
                    default:
                        // Fallback to circular hit detection
                        return Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2) <= SYMBOL_RADIUS;
                }
            }
        }

        // ProbanadArrow class
        class ProbanadArrow {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.selected = false;
                this.size = 25; // Length of the arrow (shortened from 40)
                this.angle = -Math.PI / 4; // Northeast direction (45 degrees up and right)
            }

            draw(ctx) {
                const isDark = document.documentElement.classList.contains('dark');
                ctx.strokeStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                ctx.fillStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                ctx.lineWidth = this.selected ? 4 : 3; // Moderately thicker line

                // Calculate arrow end point
                const endX = this.x + Math.cos(this.angle) * this.size;
                const endY = this.y + Math.sin(this.angle) * this.size;

                // Draw arrow shaft
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Draw arrowhead
                const arrowHeadLength = 12;
                const arrowHeadAngle = Math.PI / 6; // 30 degrees

                // Left side of arrowhead
                const leftHeadX = endX - arrowHeadLength * Math.cos(this.angle - arrowHeadAngle);
                const leftHeadY = endY - arrowHeadLength * Math.sin(this.angle - arrowHeadAngle);

                // Right side of arrowhead
                const rightHeadX = endX - arrowHeadLength * Math.cos(this.angle + arrowHeadAngle);
                const rightHeadY = endY - arrowHeadLength * Math.sin(this.angle + arrowHeadAngle);

                // Draw arrowhead as a filled triangle
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(leftHeadX, leftHeadY);
                ctx.lineTo(rightHeadX, rightHeadY);
                ctx.closePath();
                ctx.fill();
            }

            contains(x, y) {
                // Check if point is near the arrow line
                const endX = this.x + Math.cos(this.angle) * this.size;
                const endY = this.y + Math.sin(this.angle) * this.size;
                
                const distance = this.distanceToLine(x, y, this.x, this.y, endX, endY);
                return distance <= 8; // 8 pixel tolerance for clicking
            }

            distanceToLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // TextBox class
        class TextBox {
            constructor(x, y, text, id) {
                this.x = x;
                this.y = y;
                this.text = text || 'Double-click to edit';
                this.id = id;
                this.selected = false;
                this.fontSize = 14;
                this.fontFamily = 'Arial';
                this.width = 120;
                this.height = 24;
                this.padding = 8;
                this.maxWidth = 300; // Custom maximum width for text wrapping
                this.minWidth = 80;   // Minimum width
                this.minHeight = 32;  // Minimum height
                this.handleSize = 8;  // Size of resize handles
            }

            draw(ctx) {
                const isDark = document.documentElement.classList.contains('dark');
                
                // Set font for text measurement
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                
                // Configure text wrapping using custom maxWidth
                const lineHeight = this.fontSize * 1.2; // Line height with some spacing
                
                // Wrap text into lines using the textbox's custom maxWidth
                const wrappedLines = this.wrapText(ctx, this.text, this.maxWidth - this.padding * 2);
                
                // Calculate dimensions based on wrapped text
                const textWidth = Math.min(this.maxWidth - this.padding * 2, Math.max(...wrappedLines.map(line => ctx.measureText(line).width)));
                const textHeight = wrappedLines.length * lineHeight;
                
                // Update box dimensions with padding, but respect minimum sizes
                this.width = Math.max(this.minWidth, textWidth + this.padding * 2);
                this.height = Math.max(this.minHeight, textHeight + this.padding * 2);
                
                // Only draw background and border when selected
                if (this.selected) {
                    // Draw background box
                    ctx.fillStyle = isDark ? '#374151' : '#f9fafb';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // Draw border
                    ctx.strokeStyle = '#5D5CDE';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                    
                    // Draw resize handles if selected
                    this.drawResizeHandles(ctx, isDark);
                }
                
                // Draw text line by line
                ctx.fillStyle = isDark ? '#ffffff' : '#000000';
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                
                wrappedLines.forEach((line, index) => {
                    const yPos = this.y + this.padding + (index * lineHeight);
                    ctx.fillText(line, this.x + this.padding, yPos);
                });
            }

            drawResizeHandles(ctx, isDark) {
                const handleColor = '#5D5CDE';
                const handleBorderColor = isDark ? '#ffffff' : '#000000';
                
                // Define handle positions (corners)
                const handles = [
                    { x: this.x + this.width - this.handleSize, y: this.y + this.height - this.handleSize, cursor: 'nw-resize' }, // Bottom-right
                    { x: this.x, y: this.y + this.height - this.handleSize, cursor: 'ne-resize' }, // Bottom-left
                    { x: this.x + this.width - this.handleSize, y: this.y, cursor: 'ne-resize' }, // Top-right
                    { x: this.x, y: this.y, cursor: 'nw-resize' }  // Top-left
                ];
                
                // Draw each handle
                handles.forEach(handle => {
                    // Draw handle background
                    ctx.fillStyle = handleColor;
                    ctx.fillRect(handle.x, handle.y, this.handleSize, this.handleSize);
                    
                    // Draw handle border
                    ctx.strokeStyle = handleBorderColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(handle.x, handle.y, this.handleSize, this.handleSize);
                });
            }

            getResizeHandleAt(x, y) {
                if (!this.selected) return null;
                
                const handles = [
                    { name: 'bottom-right', x: this.x + this.width - this.handleSize, y: this.y + this.height - this.handleSize },
                    { name: 'bottom-left', x: this.x, y: this.y + this.height - this.handleSize },
                    { name: 'top-right', x: this.x + this.width - this.handleSize, y: this.y },
                    { name: 'top-left', x: this.x, y: this.y }
                ];
                
                for (let handle of handles) {
                    if (x >= handle.x && x <= handle.x + this.handleSize &&
                        y >= handle.y && y <= handle.y + this.handleSize) {
                        return handle.name;
                    }
                }
                
                return null;
            }

            wrapText(ctx, text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';

                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    const testLine = currentLine + (currentLine ? ' ' : '') + word;
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;

                    if (testWidth > maxWidth && currentLine) {
                        // Current line is full, start a new line
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }

                // Add the last line
                if (currentLine) {
                    lines.push(currentLine);
                }

                // Handle case where there are no spaces (single long word)
                if (lines.length === 0 && text.length > 0) {
                    // Break long words by character if needed
                    let charLine = '';
                    for (let char of text) {
                        const testLine = charLine + char;
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth && charLine) {
                            lines.push(charLine);
                            charLine = char;
                        } else {
                            charLine = testLine;
                        }
                    }
                    if (charLine) {
                        lines.push(charLine);
                    }
                }

                return lines.length > 0 ? lines : [''];
            }

            contains(x, y) {
                return x >= this.x && x <= this.x + this.width && 
                       y >= this.y && y <= this.y + this.height;
            }
        }

        // SiblingConnection class for connecting multiple siblings
        class SiblingConnection {
            constructor(siblings) {
                this.siblings = siblings; // Array of Individual objects
                this.selected = false;
                this.type = 'sibling';
            }

            draw(ctx) {
                if (this.siblings.length < 2) return;

                ctx.save(); // Save context state before drawing

                const isDark = document.documentElement.classList.contains('dark');
                ctx.strokeStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                ctx.lineWidth = this.selected ? 3 : 2;

                // Sort siblings by x position
                const sortedSiblings = [...this.siblings].sort((a, b) => a.x - b.x);

                // Calculate the horizontal line Y position
                // It should be halfway between current generation and the one above
                const siblingY = sortedSiblings[0].y;
                const generationSpacing = 150; // From SNAP_LINES spacing
                const horizontalLineY = siblingY - generationSpacing / 2;

                // Get leftmost and rightmost connection points for the horizontal sibling line
                // Connection points are: regular sibling X positions, or center X of multiples groups
                const connectionPoints = [];
                const processedMultiplesForLine = new Set();

                sortedSiblings.forEach(sibling => {
                    const multiplesGroup = multiplesConnections.find(multConn =>
                        multConn.multiples.includes(sibling)
                    );

                    if (multiplesGroup && !processedMultiplesForLine.has(multiplesGroup)) {
                        // This sibling is part of a multiples group - use center of group
                        processedMultiplesForLine.add(multiplesGroup);
                        const sortedMultiples = [...multiplesGroup.multiples].sort((a, b) => a.x - b.x);
                        const centerX = (sortedMultiples[0].x + sortedMultiples[sortedMultiples.length - 1].x) / 2;
                        connectionPoints.push(centerX);
                    } else if (!multiplesGroup) {
                        // Regular sibling - use its X position
                        connectionPoints.push(sibling.x);
                    }
                    // If already processed as part of multiples group, skip
                });

                // Horizontal line spans from leftmost to rightmost connection point
                const leftmostX = Math.min(...connectionPoints);
                const rightmostX = Math.max(...connectionPoints);

                // Draw horizontal line above siblings
                ctx.beginPath();
                ctx.moveTo(leftmostX, horizontalLineY);
                ctx.lineTo(rightmostX, horizontalLineY);
                ctx.stroke();

                // Draw vertical stems from horizontal line down to siblings
                // Group siblings by multiples - if they're part of a multiples group, draw one stem to the vertex
                const processedMultiples = new Set();

                sortedSiblings.forEach(sibling => {
                    // Check if this sibling is part of a multiples group
                    const multiplesGroup = multiplesConnections.find(multConn =>
                        multConn.multiples.includes(sibling)
                    );

                    if (multiplesGroup && !processedMultiples.has(multiplesGroup)) {
                        // This sibling is part of a multiples group
                        // The MultiplesConnection will draw diagonal lines from the sibling line (no vertical stem needed)
                        processedMultiples.add(multiplesGroup);
                        // Don't draw any stem - just let the diagonal lines connect directly
                    } else if (!multiplesGroup) {
                        // Regular sibling - draw vertical stem to symbol
                        ctx.beginPath();
                        ctx.moveTo(sibling.x, horizontalLineY);
                        ctx.lineTo(sibling.x, sibling.y - SYMBOL_RADIUS);
                        ctx.stroke();
                    }
                    // If multiplesGroup exists but already processed, skip (don't draw duplicate stems)
                });

                ctx.restore(); // Restore context state after drawing
            }

            contains(x, y) {
                if (this.siblings.length < 2) return false;

                const sortedSiblings = [...this.siblings].sort((a, b) => a.x - b.x);
                const siblingY = sortedSiblings[0].y;
                const generationSpacing = 150;
                const horizontalLineY = siblingY - generationSpacing / 2;

                const leftmostX = sortedSiblings[0].x;
                const rightmostX = sortedSiblings[sortedSiblings.length - 1].x;

                // Check if click is near the horizontal line
                if (Math.abs(y - horizontalLineY) <= 8 && x >= leftmostX && x <= rightmostX) {
                    return true;
                }

                // Check if click is near any vertical stem
                const processedMultiples = new Set();

                for (let sibling of sortedSiblings) {
                    // Check if this sibling is part of a multiples group
                    const multiplesGroup = multiplesConnections.find(multConn =>
                        multConn.multiples.includes(sibling)
                    );

                    if (multiplesGroup && !processedMultiples.has(multiplesGroup)) {
                        // Check click distance to vertex stem
                        processedMultiples.add(multiplesGroup);

                        const sortedMultiples = [...multiplesGroup.multiples].sort((a, b) => a.x - b.x);
                        const leftmostMultX = sortedMultiples[0].x;
                        const rightmostMultX = sortedMultiples[sortedMultiples.length - 1].x;
                        const vertexX = (leftmostMultX + rightmostMultX) / 2;
                        const vertexY = sortedMultiples[0].y - generationSpacing / 3;

                        const dist = this.distanceToLine(x, y, vertexX, horizontalLineY, vertexX, vertexY);
                        if (dist <= 8) return true;
                    } else if (!multiplesGroup) {
                        // Regular sibling - check distance to stem
                        const dist = this.distanceToLine(x, y, sibling.x, horizontalLineY, sibling.x, sibling.y - SYMBOL_RADIUS);
                        if (dist <= 8) return true;
                    }
                }

                return false;
            }

            distanceToLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // MultiplesConnection class for twins, triplets, etc.
        class MultiplesConnection {
            constructor(multiples) {
                this.multiples = multiples; // Array of Individual objects (twins, triplets, etc.)
                this.selected = false;
                this.type = 'multiples';
            }

            draw(ctx) {
                if (this.multiples.length < 2) return;

                ctx.save(); // Save context state before drawing

                const isDark = document.documentElement.classList.contains('dark');
                ctx.strokeStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                ctx.lineWidth = this.selected ? 3 : 2;

                // Sort multiples by x position
                const sortedMultiples = [...this.multiples].sort((a, b) => a.x - b.x);

                // Calculate positions
                const multiplesY = sortedMultiples[0].y;
                const generationSpacing = 150; // From SNAP_LINES spacing
                const apexY = multiplesY - generationSpacing / 3; // Vertex Y position (1/3 between snap lines)
                const siblingLineY = multiplesY - generationSpacing / 2; // Horizontal sibling line Y position (1/2 between snap lines)

                // Calculate center X position (midpoint of all multiples)
                const leftmostX = sortedMultiples[0].x;
                const rightmostX = sortedMultiples[sortedMultiples.length - 1].x;
                const centerX = (leftmostX + rightmostX) / 2;

                // Check if these multiples are part of a sibling connection
                const isPartOfSiblingConnection = siblingConnections.some(sibConn =>
                    this.multiples.some(mult => sibConn.siblings.includes(mult))
                );

                // Define the short vertical connector from horizontal line
                const shortConnectorLength = 15; // Length of short vertical line from horizontal line
                const connectorBottomY = siblingLineY + shortConnectorLength;

                if (!isPartOfSiblingConnection) {
                    // Draw horizontal line at sibling line level (where parent connection arrives)
                    ctx.beginPath();
                    ctx.moveTo(centerX - 10, siblingLineY); // Small horizontal line centered
                    ctx.lineTo(centerX + 10, siblingLineY);
                    ctx.stroke();

                    // Draw short vertical line descending from horizontal line
                    ctx.beginPath();
                    ctx.moveTo(centerX, siblingLineY);
                    ctx.lineTo(centerX, connectorBottomY);
                    ctx.stroke();

                    // Draw vertical stem from connector bottom to apex (with gap)
                    ctx.beginPath();
                    ctx.moveTo(centerX, connectorBottomY);
                    ctx.lineTo(centerX, apexY);
                    ctx.stroke();

                    // Draw diagonal lines from vertex to each multiple symbol
                    sortedMultiples.forEach(multiple => {
                        ctx.beginPath();
                        ctx.moveTo(centerX, apexY);
                        ctx.lineTo(multiple.x, multiple.y - SYMBOL_RADIUS);
                        ctx.stroke();
                    });
                } else {
                    // Part of sibling connection - draw short vertical connector then diagonal lines
                    // Draw short vertical line descending from horizontal line
                    ctx.beginPath();
                    ctx.moveTo(centerX, siblingLineY);
                    ctx.lineTo(centerX, connectorBottomY);
                    ctx.stroke();

                    // Draw diagonal lines from connector bottom to symbols
                    sortedMultiples.forEach(multiple => {
                        ctx.beginPath();
                        ctx.moveTo(centerX, connectorBottomY);
                        ctx.lineTo(multiple.x, multiple.y - SYMBOL_RADIUS);
                        ctx.stroke();
                    });
                }

                ctx.restore(); // Restore context state after drawing
            }

            contains(x, y) {
                if (this.multiples.length < 2) return false;

                const sortedMultiples = [...this.multiples].sort((a, b) => a.x - b.x);
                const multiplesY = sortedMultiples[0].y;
                const generationSpacing = 150;
                const apexY = multiplesY - generationSpacing / 3; // Vertex Y position
                const siblingLineY = multiplesY - generationSpacing / 2; // Horizontal sibling line Y position
                const shortConnectorLength = 15; // Must match the value in draw()
                const connectorBottomY = siblingLineY + shortConnectorLength;

                const leftmostX = sortedMultiples[0].x;
                const rightmostX = sortedMultiples[sortedMultiples.length - 1].x;
                const centerX = (leftmostX + rightmostX) / 2;

                // Check if click is near the horizontal line at sibling line level
                if (Math.abs(y - siblingLineY) <= 8 && x >= centerX - 10 && x <= centerX + 10) {
                    return true;
                }

                // Check if click is near the short vertical connector
                const distToConnector = this.distanceToLine(x, y, centerX, siblingLineY, centerX, connectorBottomY);
                if (distToConnector <= 8) return true;

                // Check if click is near the vertical stem from connector bottom to apex
                const distToVerticalStem = this.distanceToLine(x, y, centerX, connectorBottomY, centerX, apexY);
                if (distToVerticalStem <= 8) return true;

                // Check if click is near any of the diagonal lines from vertex to symbols
                for (let multiple of sortedMultiples) {
                    const dist = this.distanceToLine(x, y, centerX, apexY, multiple.x, multiple.y - SYMBOL_RADIUS);
                    if (dist <= 8) return true;
                }

                return false;
            }

            distanceToLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // ParentSiblingConnection class for connecting parent(s) to child/sibling group
        class ParentSiblingConnection {
            constructor(parentSource, childTarget) {
                // parentSource can be a marriageConnection or a single parent Individual
                // childTarget can be a siblingConnection or a single child Individual
                this.parentSource = parentSource;
                this.childTarget = childTarget;
                this.selected = false;
                this.type = 'parent-sibling';
            }

            draw(ctx) {
                ctx.save(); // Save context state before drawing

                const isDark = document.documentElement.classList.contains('dark');
                ctx.strokeStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                ctx.lineWidth = this.selected ? 3 : 2;

                let startX, startY, endX, endY;

                // Determine start point (parent side)
                if (this.parentSource.type === 'marriage' || this.parentSource.type === 'consanguineous') {
                    // It's a marriage connection
                    const parent1 = this.parentSource.from;
                    const parent2 = this.parentSource.to;
                    startX = (parent1.x + parent2.x) / 2;
                    startY = (parent1.y + parent2.y) / 2;
                } else {
                    // It's a single parent Individual
                    startX = this.parentSource.x;
                    startY = this.parentSource.y + SYMBOL_RADIUS; // Bottom of parent symbol
                }

                // Determine end point and draw connection
                if (this.childTarget.type === 'sibling') {
                    // It's a sibling connection - draw vertical line to CENTER of ALL individual siblings
                    const sortedSiblings = [...this.childTarget.siblings].sort((a, b) => a.x - b.x);
                    const siblingY = sortedSiblings[0].y;
                    const generationSpacing = 150;

                    // Calculate the center of ALL individual siblings
                    // IMPORTANT: If any sibling is part of a multiples group, we must include
                    // ALL members of that multiples group in our calculation
                    const allIndividuals = [];
                    const processedMultiplesGroups = new Set();

                    sortedSiblings.forEach(sibling => {
                        const multiplesGroup = multiplesConnections.find(multConn =>
                            multConn.multiples.includes(sibling)
                        );

                        if (multiplesGroup && !processedMultiplesGroups.has(multiplesGroup)) {
                            // This sibling is part of a multiples group - add ALL members of the group
                            processedMultiplesGroups.add(multiplesGroup);
                            multiplesGroup.multiples.forEach(multiple => {
                                allIndividuals.push(multiple);
                            });
                        } else if (!multiplesGroup) {
                            // Regular sibling - add just this one
                            allIndividuals.push(sibling);
                        }
                        // If already processed as part of multiples group, skip
                    });

                    // Now get all X positions
                    const allIndividualX = allIndividuals.map(ind => ind.x);
                    const leftmostIndividual = Math.min(...allIndividualX);
                    const rightmostIndividual = Math.max(...allIndividualX);

                    // Vertical line connects to center of ALL individuals
                    endX = (leftmostIndividual + rightmostIndividual) / 2;

                    endY = siblingY - generationSpacing / 2; // Sibling line Y position
                } else if (this.childTarget.type === 'multiples') {
                    // It's a multiples connection - draw vertical line to center of the multiples group
                    // The MultiplesConnection itself will draw from this horizontal line down to the vertex
                    const sortedMultiples = [...this.childTarget.multiples].sort((a, b) => a.x - b.x);
                    const multiplesY = sortedMultiples[0].y;
                    const generationSpacing = 150;

                    // Get all individual X positions
                    const allIndividualX = sortedMultiples.map(m => m.x);
                    const leftmostX = Math.min(...allIndividualX);
                    const rightmostX = Math.max(...allIndividualX);
                    endX = (leftmostX + rightmostX) / 2; // Center of the entire multiples group

                    endY = multiplesY - generationSpacing / 2; // Sibling line Y position (same as sibling connections)
                } else {
                    // It's a single child Individual - draw vertical line directly to child
                    endX = this.childTarget.x;
                    endY = this.childTarget.y - SYMBOL_RADIUS; // Top of child symbol
                }

                // Draw simple vertical line
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                ctx.restore(); // Restore context state after drawing
            }

            contains(x, y) {
                let startX, startY, endX, endY;

                // Determine start point (parent side)
                if (this.parentSource.type === 'marriage' || this.parentSource.type === 'consanguineous') {
                    const parent1 = this.parentSource.from;
                    const parent2 = this.parentSource.to;
                    startX = (parent1.x + parent2.x) / 2;
                    startY = (parent1.y + parent2.y) / 2;
                } else {
                    startX = this.parentSource.x;
                    startY = this.parentSource.y + SYMBOL_RADIUS;
                }

                // Determine end point based on child type
                if (this.childTarget.type === 'sibling') {
                    // Sibling connection - calculate center of ALL individual siblings (same logic as draw)
                    const sortedSiblings = [...this.childTarget.siblings].sort((a, b) => a.x - b.x);
                    const siblingY = sortedSiblings[0].y;
                    const generationSpacing = 150;

                    // Calculate the center of ALL individual siblings
                    // Include ALL members of any multiples groups
                    const allIndividuals = [];
                    const processedMultiplesGroups = new Set();

                    sortedSiblings.forEach(sibling => {
                        const multiplesGroup = multiplesConnections.find(multConn =>
                            multConn.multiples.includes(sibling)
                        );

                        if (multiplesGroup && !processedMultiplesGroups.has(multiplesGroup)) {
                            processedMultiplesGroups.add(multiplesGroup);
                            multiplesGroup.multiples.forEach(multiple => {
                                allIndividuals.push(multiple);
                            });
                        } else if (!multiplesGroup) {
                            allIndividuals.push(sibling);
                        }
                    });

                    const allIndividualX = allIndividuals.map(ind => ind.x);
                    const leftmostIndividual = Math.min(...allIndividualX);
                    const rightmostIndividual = Math.max(...allIndividualX);

                    // Vertical line connects to center of ALL individuals
                    endX = (leftmostIndividual + rightmostIndividual) / 2;

                    endY = siblingY - generationSpacing / 2;
                } else if (this.childTarget.type === 'multiples') {
                    // Multiples connection - connect to center of entire multiples group
                    const sortedMultiples = [...this.childTarget.multiples].sort((a, b) => a.x - b.x);
                    const multiplesY = sortedMultiples[0].y;
                    const generationSpacing = 150;

                    const allIndividualX = sortedMultiples.map(m => m.x);
                    const leftmostX = Math.min(...allIndividualX);
                    const rightmostX = Math.max(...allIndividualX);
                    endX = (leftmostX + rightmostX) / 2; // Center of the entire multiples group

                    endY = multiplesY - generationSpacing / 2;
                } else {
                    // Single child
                    endX = this.childTarget.x;
                    endY = this.childTarget.y - SYMBOL_RADIUS;
                }

                // Check if click is near the line
                const dist = this.distanceToLine(x, y, startX, startY, endX, endY);
                return dist <= 8;
            }

            distanceToLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // Connection class for relationships between individuals
        class Connection {
            constructor(from, to, type) {
                this.from = from;
                this.to = to;
                this.type = type; // 'marriage', 'consanguineous', 'identical', 'donor'
                this.selected = false;
                // Custom positioning for draggable connections
                this.customYOffset = 0; // Vertical offset from default position
                this.hasCustomPosition = false; // Track if user has customized position
            }

            // Calculate connection point on a symbol based on angle
            getConnectionPoint(symbol, otherSymbol, yOffset = 0) {
                // Calculate angle from this symbol to the other
                const dx = otherSymbol.x - symbol.x;
                const dy = (otherSymbol.y + yOffset) - (symbol.y + yOffset);
                const angle = Math.atan2(dy, dx);

                // Calculate point on the edge of the symbol
                const x = symbol.x + Math.cos(angle) * SYMBOL_RADIUS;
                const y = symbol.y + yOffset + Math.sin(angle) * SYMBOL_RADIUS;

                return { x, y };
            }

            // Get the actual start and end points of the line
            getLinePoints() {
                const fromPoint = this.getConnectionPoint(this.from, this.to, this.customYOffset);
                const toPoint = this.getConnectionPoint(this.to, this.from, this.customYOffset);
                return { fromPoint, toPoint };
            }

            draw(ctx) {
                ctx.save(); // Save context state before drawing

                const isDark = document.documentElement.classList.contains('dark');
                ctx.strokeStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                ctx.lineWidth = this.selected ? 3 : 2;

                if (this.type === 'marriage') {
                    // Get connection points
                    const { fromPoint, toPoint } = this.getLinePoints();

                    ctx.beginPath();
                    ctx.moveTo(fromPoint.x, fromPoint.y);
                    ctx.lineTo(toPoint.x, toPoint.y);
                    ctx.stroke();

                    // Draw drag handle in the middle if selected
                    if (this.selected) {
                        const midX = (fromPoint.x + toPoint.x) / 2;
                        const midY = (fromPoint.y + toPoint.y) / 2;

                        ctx.fillStyle = '#5D5CDE';
                        ctx.beginPath();
                        ctx.arc(midX, midY, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                } else if (this.type === 'consanguineous') {
                    // Get connection points
                    const { fromPoint, toPoint } = this.getLinePoints();

                    // Calculate perpendicular offset for double line
                    const dx = toPoint.x - fromPoint.x;
                    const dy = toPoint.y - fromPoint.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const perpX = -dy / length * 3; // 3 pixels spacing
                    const perpY = dx / length * 3;

                    // Draw upper line
                    ctx.beginPath();
                    ctx.moveTo(fromPoint.x + perpX, fromPoint.y + perpY);
                    ctx.lineTo(toPoint.x + perpX, toPoint.y + perpY);
                    ctx.stroke();

                    // Draw lower line
                    ctx.beginPath();
                    ctx.moveTo(fromPoint.x - perpX, fromPoint.y - perpY);
                    ctx.lineTo(toPoint.x - perpX, toPoint.y - perpY);
                    ctx.stroke();

                    // Draw drag handle in the middle if selected
                    if (this.selected) {
                        const midX = (fromPoint.x + toPoint.x) / 2;
                        const midY = (fromPoint.y + toPoint.y) / 2;

                        ctx.fillStyle = '#5D5CDE';
                        ctx.beginPath();
                        ctx.arc(midX, midY, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                } else if (this.type === 'identical') {
                    // Draw horizontal line between facing edges for identical twins/multiples on same generation
                    // Determine which symbol is on the left
                    const leftSymbol = this.from.x < this.to.x ? this.from : this.to;
                    const rightSymbol = this.from.x < this.to.x ? this.to : this.from;

                    // Use the shared y coordinate (they should be on the same generation)
                    const y = (leftSymbol.y + rightSymbol.y) / 2;

                    // Start from right edge of left symbol
                    const startX = leftSymbol.x + SYMBOL_RADIUS;
                    // End at left edge of right symbol
                    const endX = rightSymbol.x - SYMBOL_RADIUS;

                    ctx.beginPath();
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                    ctx.stroke();

                    // Draw drag handle in the middle if selected
                    if (this.selected) {
                        const midX = (startX + endX) / 2;
                        const midY = y;

                        ctx.fillStyle = '#5D5CDE';
                        ctx.beginPath();
                        ctx.arc(midX, midY, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                } else if (this.type === 'donor') {
                    // Draw dashed line for donor connections
                    const isDark = document.documentElement.classList.contains('dark');
                    ctx.strokeStyle = this.selected ? '#5D5CDE' : (isDark ? '#ffffff' : '#000000');
                    ctx.lineWidth = this.selected ? 3 : 2;
                    ctx.setLineDash([5, 5]); // Dashed line

                    ctx.beginPath();
                    ctx.moveTo(this.from.x, this.from.y);
                    ctx.lineTo(this.to.x, this.to.y);
                    ctx.stroke();

                    ctx.setLineDash([]); // Reset to solid line
                }

                ctx.restore(); // Restore context state after drawing
            }

            contains(x, y) {
                // For identical connections, use the specific line points
                if (this.type === 'identical') {
                    const leftSymbol = this.from.x < this.to.x ? this.from : this.to;
                    const rightSymbol = this.from.x < this.to.x ? this.to : this.from;
                    const lineY = (leftSymbol.y + rightSymbol.y) / 2;
                    const startX = leftSymbol.x + SYMBOL_RADIUS;
                    const endX = rightSymbol.x - SYMBOL_RADIUS;
                    const dist = this.distanceToLine(x, y, startX, lineY, endX, lineY);
                    return dist <= 8; // 8 pixel tolerance
                }

                // Check if click is near the line using actual line points
                const { fromPoint, toPoint } = this.getLinePoints();
                const dist = this.distanceToLine(x, y, fromPoint.x, fromPoint.y, toPoint.x, toPoint.y);
                return dist <= 8; // 8 pixel tolerance
            }

            // Check if click is near the drag handle (midpoint of line)
            isNearDragHandle(x, y) {
                // For identical connections, use the specific line points
                if (this.type === 'identical') {
                    const leftSymbol = this.from.x < this.to.x ? this.from : this.to;
                    const rightSymbol = this.from.x < this.to.x ? this.to : this.from;
                    const lineY = (leftSymbol.y + rightSymbol.y) / 2;
                    const startX = leftSymbol.x + SYMBOL_RADIUS;
                    const endX = rightSymbol.x - SYMBOL_RADIUS;
                    const midX = (startX + endX) / 2;
                    const midY = lineY;
                    const dist = Math.sqrt((x - midX) ** 2 + (y - midY) ** 2);
                    return dist <= 8; // 8 pixel tolerance
                }

                const { fromPoint, toPoint } = this.getLinePoints();
                const midX = (fromPoint.x + toPoint.x) / 2;
                const midY = (fromPoint.y + toPoint.y) / 2;
                const dist = Math.sqrt((x - midX) ** 2 + (y - midY) ** 2);
                return dist <= 8; // 8 pixel tolerance
            }

            distanceToLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // Initialize connections arrays
        let connections = [];
        let siblingConnections = [];
        let parentSiblingConnections = [];
        let multiplesConnections = [];

        // Canvas event handlers
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('dblclick', handleDoubleClick);
        canvas.addEventListener('contextmenu', handleRightClick);

        // Touch event handlers
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        function getCanvasCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            // Convert from viewport coordinates to canvas coordinates
            // Account for the fact that canvas internal size might be scaled by devicePixelRatio
            return {
                x: (clientX - rect.left) * (canvas.width / window.devicePixelRatio) / rect.width,
                y: (clientY - rect.top) * (canvas.height / window.devicePixelRatio) / rect.height
            };
        }

        function handleCanvasClick(event) {
            // If we just completed a drag operation, don't handle the click
            if (hasDragged) {
                hasDragged = false; // Reset for next time
                return;
            }
            
            const coords = getCanvasCoordinates(event);
            const clickedItem = findItemAt(coords.x, coords.y);
            const isCtrlClick = event.ctrlKey || event.metaKey;
            
            // Handle special tool actions on individuals
            if (clickedItem && clickedItem instanceof Individual) {
                if (currentTool === 'deceased') {
                    // Save state before changing deceased status
                    saveState();
                    clickedItem.deceased = !clickedItem.deceased;
                    draw();
                    return;
                } else if (['marriage', 'consanguineous'].includes(currentTool)) {
                    handleConnection(coords.x, coords.y);
                    return;
                }
            }
            
            // Handle separation symbol tool action
            if (currentTool === 'separated') {
                addSeparationSymbol(coords.x, coords.y);
                draw();
                return;
            }
            
            // Handle selection for any clickable item (individuals, connections, text boxes, arrows, separation symbols)
            if (clickedItem) {
                // Handle selection based on current tool and modifier keys
                if (currentTool === 'select' || isCtrlClick) {
                    if (clickedItem instanceof Individual) {
                        if (isCtrlClick) {
                            // Toggle this individual in the selection
                            if (clickedItem.selected) {
                                clickedItem.selected = false;
                                selectedIndividuals = selectedIndividuals.filter(ind => ind !== clickedItem);
                            } else {
                                clickedItem.selected = true;
                                selectedIndividuals.push(clickedItem);
                            }
                        } else {
                            // Single selection (clear others)
                            individuals.forEach(ind => ind.selected = false);
                            connections.forEach(conn => conn.selected = false);
                            textBoxes.forEach(tb => tb.selected = false);
                            probandArrows.forEach(arrow => arrow.selected = false);
                            separationSymbols.forEach(symbol => symbol.selected = false);
                            siblingConnections.forEach(sibConn => sibConn.selected = false);
                            multiplesConnections.forEach(multConn => multConn.selected = false);
                            parentSiblingConnections.forEach(psConn => psConn.selected = false);
                            selectedIndividuals = [];

                            clickedItem.selected = true;
                            selectedIndividuals.push(clickedItem);
                        }
                    } else {
                        // For connections, text boxes, proband arrows, and separation symbols
                        if (!isCtrlClick) {
                            individuals.forEach(ind => ind.selected = false);
                            connections.forEach(conn => conn.selected = false);
                            textBoxes.forEach(tb => tb.selected = false);
                            probandArrows.forEach(arrow => arrow.selected = false);
                            separationSymbols.forEach(symbol => symbol.selected = false);
                            siblingConnections.forEach(sibConn => sibConn.selected = false);
                            multiplesConnections.forEach(multConn => multConn.selected = false);
                            parentSiblingConnections.forEach(psConn => psConn.selected = false);
                            selectedIndividuals = [];
                        }
                        
                        // Toggle selection for Ctrl+click on non-individuals
                        if (isCtrlClick) {
                            clickedItem.selected = !clickedItem.selected;
                        } else {
                            clickedItem.selected = true;
                        }
                    }
                    draw();
                    return;
                } else if (currentTool !== 'select') {
                    // For non-select tools, still allow basic selection but don't prevent tool action
                    if (!isCtrlClick) {
                        individuals.forEach(ind => ind.selected = false);
                        connections.forEach(conn => conn.selected = false);
                        textBoxes.forEach(tb => tb.selected = false);
                        siblingConnections.forEach(sibConn => sibConn.selected = false);
                        multiplesConnections.forEach(multConn => multConn.selected = false);
                        parentSiblingConnections.forEach(psConn => psConn.selected = false);
                        selectedIndividuals = [];
                    }
                    
                    if (clickedItem instanceof Individual) {
                        clickedItem.selected = true;
                        selectedIndividuals.push(clickedItem);
                    } else {
                        clickedItem.selected = true;
                    }
                    updateFamilyConnectionButton();
                    draw();
                    return;
                }
            }
            
            // If clicking on empty space
            if (!isCtrlClick) {
                individuals.forEach(ind => ind.selected = false);
                connections.forEach(conn => conn.selected = false);
                textBoxes.forEach(tb => tb.selected = false);
                probandArrows.forEach(arrow => arrow.selected = false);
                separationSymbols.forEach(symbol => symbol.selected = false);
                siblingConnections.forEach(sibConn => sibConn.selected = false);
                multiplesConnections.forEach(multConn => multConn.selected = false);
                parentSiblingConnections.forEach(psConn => psConn.selected = false);
                selectedIndividuals = [];
            }
            
            // Use the current tool for placing new symbols or text boxes (only on empty space)
            if (['male', 'female', 'unknown', 'miscarriage', 'pregnancy', 'ectopic', 'tab'].includes(currentTool)) {
                addIndividual(coords.x, coords.y, currentTool);
            } else if (currentTool === 'textbox') {
                addTextBox(coords.x, coords.y);
            } else if (currentTool === 'proband') {
                addProbandArrow(coords.x, coords.y);
            }
            
            draw();
        }

        function handleMouseDown(event) {
            const coords = getCanvasCoordinates(event);
            const item = findItemAt(coords.x, coords.y);
            
            // Reset drag flag
            hasDragged = false;
            
            // Prevent drag selection from starting when we click on an item for special tools
            if (item && item instanceof Individual && ['deceased', 'marriage'].includes(currentTool)) {
                // Let handleCanvasClick handle these cases
                return;
            }
            
            // Check if clicking on a text box resize handle
            if (item && item instanceof TextBox) {
                const resizeHandleName = item.getResizeHandleAt(coords.x, coords.y);
                if (resizeHandleName) {
                    // Save state before resizing
                    saveState();
                    
                    isResizing = true;
                    resizeHandle = resizeHandleName;
                    selectedItem = item;
                    resizeStartPos.x = coords.x;
                    resizeStartPos.y = coords.y;
                    resizeStartSize.width = item.width;
                    resizeStartSize.height = item.height;
                    resizeStartSize.maxWidth = item.maxWidth;
                    
                    // Set appropriate cursor for resize direction
                    canvas.style.cursor = getResizeCursor(resizeHandleName);
                    
                    event.preventDefault();
                    return;
                }
            }
            
            // ‚ú® PRIORITY 1: GROUP DRAGGING - Check this FIRST and ALWAYS when multiple individuals are selected
            if (selectedIndividuals.length > 1) {
                // Special case: If we clicked on an individual that's part of the selected group,
                // we should do group dragging, not single item dragging
                if (item && item instanceof Individual && selectedIndividuals.includes(item)) {
                    // Save state before potential move
                    saveState();
                    
                    // Set group dragging flags
                    isGroupDragging = true;
                    isDragging = true;
                    
                    // Calculate offsets for all selected individuals
                    groupDragOffsets = selectedIndividuals.map(ind => ({
                        individual: ind,
                        offsetX: coords.x - ind.x,
                        offsetY: coords.y - ind.y
                    }));
                    
                    // Change cursor to indicate group dragging
                    canvas.style.cursor = 'grabbing';
                    
                    // Add visual feedback for group drag
                    showDragFeedback('group', selectedIndividuals.length);
                    
                    event.preventDefault();
                    return;
                }
                
                // Also check if clicking in empty space within group bounds
                const bounds = getGroupBounds();
                
                if (bounds && coords.x >= bounds.left && coords.x <= bounds.right && 
                    coords.y >= bounds.top && coords.y <= bounds.bottom && !item) {
                    
                    // Save state before potential move
                    saveState();
                    
                    // Set group dragging flags
                    isGroupDragging = true;
                    isDragging = true;
                    
                    // Calculate offsets for all selected individuals
                    groupDragOffsets = selectedIndividuals.map(ind => ({
                        individual: ind,
                        offsetX: coords.x - ind.x,
                        offsetY: coords.y - ind.y
                    }));
                    
                    // Change cursor to indicate group dragging
                    canvas.style.cursor = 'grabbing';
                    
                    // Add visual feedback for group drag
                    showDragFeedback('group', selectedIndividuals.length);
                    
                    event.preventDefault();
                    return;
                }
            }
            
            // PRIORITY 2a: Check if clicking on a connection drag handle
            if (item && item instanceof Connection && (item.type === 'marriage' || item.type === 'consanguineous' || item.type === 'identical')) {
                if (item.selected && item.isNearDragHandle(coords.x, coords.y)) {
                    // Save state before dragging connection
                    saveState();

                    isDraggingConnection = true;
                    draggedConnection = item;
                    connectionDragStartY = coords.y;

                    // Change cursor to indicate dragging
                    canvas.style.cursor = 'ns-resize';

                    event.preventDefault();
                    return;
                }
            }

            // PRIORITY 2b: Single item dragging - only if we're NOT doing group dragging
            if (item && (item instanceof Individual || item instanceof TextBox || item instanceof ProbanadArrow || item instanceof SeparationSymbol)) {
                // Save state before potential move
                saveState();

                selectedItem = item;
                isDragging = true;
                dragOffset.x = coords.x - item.x;
                dragOffset.y = coords.y - item.y;

                // Change cursor to indicate dragging
                canvas.style.cursor = 'grabbing';

                // Add visual feedback for single item drag
                const itemType = item instanceof Individual ? item.type :
                               item instanceof TextBox ? 'textbox' :
                               item instanceof ProbanadArrow ? 'arrow' : 'separation';
                showDragFeedback('single', 1, itemType);

                event.preventDefault();
                return;
            }
            
            // PRIORITY 3: Group selection - clicking on empty space
            if (!item) {
                isGroupSelecting = true;
                groupSelectStart.x = coords.x;
                groupSelectStart.y = coords.y;
                groupSelectEnd.x = coords.x;
                groupSelectEnd.y = coords.y;
                
                // Set additive selection flag
                isAdditiveSelection = event.ctrlKey || event.metaKey;
                
                // Don't clear selections if Ctrl is held
                if (!isAdditiveSelection) {
                    individuals.forEach(ind => ind.selected = false);
                    connections.forEach(conn => conn.selected = false);
                    selectedIndividuals = [];
                }
                
                canvas.style.cursor = 'crosshair';
                event.preventDefault();
            }
        }

        function handleMouseMove(event) {
            if (isResizing && selectedItem) {
                const coords = getCanvasCoordinates(event);
                performResize(coords);
                hasDragged = true;
                draw();
            } else if (isDraggingConnection && draggedConnection) {
                // Drag connection to adjust its position
                const coords = getCanvasCoordinates(event);
                const deltaY = coords.y - connectionDragStartY;
                draggedConnection.customYOffset += deltaY;
                draggedConnection.hasCustomPosition = true;
                connectionDragStartY = coords.y;
                hasDragged = true;
                draw();
            } else if (isDragging) {
                const coords = getCanvasCoordinates(event);

                if (isGroupDragging) {
                    // Move all selected individuals as a group
                    groupDragOffsets.forEach(dragInfo => {
                        const newX = coords.x - dragInfo.offsetX;
                        const newY = coords.y - dragInfo.offsetY;

                        dragInfo.individual.x = newX;
                        dragInfo.individual.y = snapToLine(newY);
                    });
                } else if (selectedItem) {
                    // Move single individual or text box
                    selectedItem.x = coords.x - dragOffset.x;
                    if (selectedItem instanceof Individual) {
                        selectedItem.y = snapToLine(coords.y - dragOffset.y);
                    } else {
                        selectedItem.y = coords.y - dragOffset.y;
                    }
                }

                hasDragged = true;
                draw();
            } else if (isGroupSelecting) {
                const coords = getCanvasCoordinates(event);
                groupSelectEnd.x = coords.x;
                groupSelectEnd.y = coords.y;
                
                // Auto-scroll when selection approaches viewport edges
                handleAutoScrollDuringSelection(event);
                
                // Check if we've moved enough to consider this a drag
                const dragDistance = Math.sqrt(
                    Math.pow(coords.x - groupSelectStart.x, 2) + 
                    Math.pow(coords.y - groupSelectStart.y, 2)
                );
                
                if (dragDistance > 5) { // 5 pixel threshold
                    hasDragged = true;
                }
                
                // Update group selection
                updateGroupSelection();
                updateFamilyConnectionButton();
                draw();
            } else {
                // Update cursor based on hover over draggable items
                updateCursorForHover(event);
            }
        }

        function performResize(coords) {
            const deltaX = coords.x - resizeStartPos.x;
            const deltaY = coords.y - resizeStartPos.y;
            
            const textBox = selectedItem;
            let newWidth = resizeStartSize.width;
            let newHeight = resizeStartSize.height;
            let newMaxWidth = resizeStartSize.maxWidth;
            let newX = textBox.x;
            let newY = textBox.y;
            
            switch (resizeHandle) {
                case 'bottom-right':
                    newWidth = Math.max(textBox.minWidth, resizeStartSize.width + deltaX);
                    newMaxWidth = Math.max(textBox.minWidth, resizeStartSize.maxWidth + deltaX);
                    // Height will auto-adjust based on text content
                    break;
                    
                case 'bottom-left':
                    newWidth = Math.max(textBox.minWidth, resizeStartSize.width - deltaX);
                    newMaxWidth = Math.max(textBox.minWidth, resizeStartSize.maxWidth - deltaX);
                    newX = resizeStartPos.x - (newMaxWidth - resizeStartSize.maxWidth);
                    break;
                    
                case 'top-right':
                    newWidth = Math.max(textBox.minWidth, resizeStartSize.width + deltaX);
                    newMaxWidth = Math.max(textBox.minWidth, resizeStartSize.maxWidth + deltaX);
                    // For top resize, we need to adjust Y position as height changes
                    const heightDiff = textBox.height - resizeStartSize.height;
                    newY = textBox.y - heightDiff;
                    break;
                    
                case 'top-left':
                    newWidth = Math.max(textBox.minWidth, resizeStartSize.width - deltaX);
                    newMaxWidth = Math.max(textBox.minWidth, resizeStartSize.maxWidth - deltaX);
                    newX = resizeStartPos.x - (newMaxWidth - resizeStartSize.maxWidth);
                    const heightDiffTL = textBox.height - resizeStartSize.height;
                    newY = textBox.y - heightDiffTL;
                    break;
            }
            
            // Update text box properties
            textBox.maxWidth = newMaxWidth;
            textBox.x = newX;
            textBox.y = newY;
        }

        function updateCursorForHover(event) {
            const coords = getCanvasCoordinates(event);
            const item = findItemAt(coords.x, coords.y);

            if (item && item instanceof TextBox && item.selected) {
                const resizeHandleName = item.getResizeHandleAt(coords.x, coords.y);
                if (resizeHandleName) {
                    canvas.style.cursor = getResizeCursor(resizeHandleName);
                    return;
                }
            }

            // Check if hovering over a connection's drag handle
            if (item && item instanceof Connection && (item.type === 'marriage' || item.type === 'consanguineous' || item.type === 'identical')) {
                if (item.selected && item.isNearDragHandle(coords.x, coords.y)) {
                    canvas.style.cursor = 'ns-resize';
                    return;
                }
            }

            // Show grab cursor for draggable items when in select mode
            if (currentTool === 'select' && item &&
                (item instanceof Individual || item instanceof TextBox || item instanceof ProbanadArrow)) {

                // Check if multiple items are selected and this item is part of the selection
                if (selectedIndividuals.length > 1 && item instanceof Individual && selectedIndividuals.includes(item)) {
                    canvas.style.cursor = 'grab'; // Group drag cursor
                } else if (selectedIndividuals.length > 1) {
                    // If multiple items selected but hovering over non-selected item
                    const bounds = getGroupBounds();
                    if (bounds && coords.x >= bounds.left && coords.x <= bounds.right &&
                        coords.y >= bounds.top && coords.y <= bounds.bottom) {
                        canvas.style.cursor = 'grab'; // Group drag cursor
                    } else {
                        canvas.style.cursor = 'grab'; // Individual item cursor
                    }
                } else {
                    canvas.style.cursor = 'grab'; // Single item cursor
                }
                return;
            }

            // Default cursor
            canvas.style.cursor = currentTool === 'select' ? 'default' : 'crosshair';
        }

        function getResizeCursor(handleName) {
            switch (handleName) {
                case 'top-left':
                case 'bottom-right':
                    return 'nw-resize';
                case 'top-right':
                case 'bottom-left':
                    return 'ne-resize';
                default:
                    return 'default';
            }
        }

        // Auto-scroll during selection variables
        let autoScrollInterval = null;
        let scrollSpeed = 8; // Pixels per frame
        let scrollEdgeThreshold = 50; // Distance from edge to trigger scroll

        function handleAutoScrollDuringSelection(event) {
            // Get viewport coordinates of the mouse
            const rect = canvas.getBoundingClientRect();
            const mouseY = event.clientY;
            const viewportTop = rect.top;
            const viewportBottom = rect.bottom;
            const viewportHeight = rect.height;
            
            // Calculate distances from top and bottom edges
            const distanceFromTop = mouseY - viewportTop;
            const distanceFromBottom = viewportBottom - mouseY;
            
            // Determine scroll direction and speed
            let scrollDirection = 0; // 0 = no scroll, -1 = up, 1 = down
            let currentScrollSpeed = 0;
            
            if (distanceFromTop < scrollEdgeThreshold && distanceFromTop > 0) {
                // Near top edge - scroll up
                scrollDirection = -1;
                currentScrollSpeed = scrollSpeed * (1 - distanceFromTop / scrollEdgeThreshold);
            } else if (distanceFromBottom < scrollEdgeThreshold && distanceFromBottom > 0) {
                // Near bottom edge - scroll down
                scrollDirection = 1;
                currentScrollSpeed = scrollSpeed * (1 - distanceFromBottom / scrollEdgeThreshold);
            }
            
            // Clear existing auto-scroll
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
            
            // Start auto-scroll if needed
            if (scrollDirection !== 0) {
                autoScrollInterval = setInterval(() => {
                    // Scroll the page
                    window.scrollBy(0, scrollDirection * currentScrollSpeed);
                    
                    // Update the selection end coordinates to account for scrolling
                    // This keeps the selection rectangle following the mouse even while scrolling
                    const newRect = canvas.getBoundingClientRect();
                    const canvasCoords = getCanvasCoordinates({
                        clientX: event.clientX,
                        clientY: event.clientY
                    });
                    
                    groupSelectEnd.x = canvasCoords.x;
                    groupSelectEnd.y = canvasCoords.y;
                    
                    // Update selection and redraw
                    updateGroupSelection();
                    updateFamilyConnectionButton();
                    draw();
                }, 16); // ~60fps
            }
        }

        function stopAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
        }

        function handleMouseUp(event) {
            // Stop auto-scroll when mouse is released
            stopAutoScroll();
            
            if (isDragging) {
                // Reset cursor
                canvas.style.cursor = currentTool === 'select' ? 'default' : 'crosshair';
                
                // Hide drag feedback
                hideDragFeedback();
            } else if (isResizing) {
                // Reset cursor after resizing
                canvas.style.cursor = currentTool === 'select' ? 'default' : 'crosshair';
            } else if (isGroupSelecting) {
                // Finish group selection
                isGroupSelecting = false;
                canvas.style.cursor = 'default';
                draw();
            }
            
            // Reset all dragging and resizing states
            isDragging = false;
            isResizing = false;
            selectedItem = null;
            resizeHandle = null;
            isGroupDragging = false;
            groupDragOffsets = [];
            isDraggingConnection = false;
            draggedConnection = null;
        }
        
        function updateGroupSelection() {
            // Calculate selection rectangle
            const left = Math.min(groupSelectStart.x, groupSelectEnd.x);
            const right = Math.max(groupSelectStart.x, groupSelectEnd.x);
            const top = Math.min(groupSelectStart.y, groupSelectEnd.y);
            const bottom = Math.max(groupSelectStart.y, groupSelectEnd.y);
            
            // If not additive selection (no Ctrl held), clear previous selections
            if (!isAdditiveSelection) {
                individuals.forEach(ind => ind.selected = false);
                connections.forEach(conn => conn.selected = false);
                textBoxes.forEach(tb => tb.selected = false);
                probandArrows.forEach(arrow => arrow.selected = false);
                siblingConnections.forEach(sibConn => sibConn.selected = false);
                multiplesConnections.forEach(multConn => multConn.selected = false);
                parentSiblingConnections.forEach(psConn => psConn.selected = false);
                selectedIndividuals = [];
            }
            
            // Select individuals within rectangle
            individuals.forEach(individual => {
                if (individual.x >= left && individual.x <= right && 
                    individual.y >= top && individual.y <= bottom) {
                    if (!individual.selected) {
                        individual.selected = true;
                        selectedIndividuals.push(individual);
                    }
                }
            });
            
            // Select text boxes within rectangle
            textBoxes.forEach(textBox => {
                if (textBox.x >= left && textBox.x <= textBox.x + textBox.width && 
                    textBox.y >= top && textBox.y <= textBox.y + textBox.height &&
                    textBox.x + textBox.width >= left && textBox.y + textBox.height >= top) {
                    if (!textBox.selected) {
                        textBox.selected = true;
                    }
                }
            });
            
            // Select proband arrows within rectangle
            probandArrows.forEach(probandArrow => {
                if (probandArrow.x >= left && probandArrow.x <= right && 
                    probandArrow.y >= top && probandArrow.y <= bottom) {
                    if (!probandArrow.selected) {
                        probandArrow.selected = true;
                    }
                }
            });
            
            // Select separation symbols within rectangle
            separationSymbols.forEach(separationSymbol => {
                if (separationSymbol.x >= left && separationSymbol.x <= right && 
                    separationSymbol.y >= top && separationSymbol.y <= bottom) {
                    if (!separationSymbol.selected) {
                        separationSymbol.selected = true;
                    }
                }
            });
            
            // Select connections within rectangle (check if both endpoints are in rectangle or line intersects)
            connections.forEach(connection => {
                const fromInside = connection.from.x >= left && connection.from.x <= right &&
                                 connection.from.y >= top && connection.from.y <= bottom;
                const toInside = connection.to.x >= left && connection.to.x <= right &&
                               connection.to.y >= top && connection.to.y <= bottom;

                // Select if both endpoints are inside rectangle or if line intersects rectangle
                if ((fromInside && toInside) || lineIntersectsRectangle(connection, left, top, right, bottom)) {
                    if (!connection.selected) {
                        connection.selected = true;
                    }
                }
            });

            // Select sibling connections within rectangle
            siblingConnections.forEach(sibConn => {
                // Check if any sibling is within the rectangle
                const hasSelectedSibling = sibConn.siblings.some(sib =>
                    sib.x >= left && sib.x <= right && sib.y >= top && sib.y <= bottom
                );
                if (hasSelectedSibling && !sibConn.selected) {
                    sibConn.selected = true;
                }
            });

            // Select multiples connections within rectangle
            multiplesConnections.forEach(multConn => {
                // Check if any multiple is within the rectangle
                const hasSelectedMultiple = multConn.multiples.some(mult =>
                    mult.x >= left && mult.x <= right && mult.y >= top && mult.y <= bottom
                );
                if (hasSelectedMultiple && !multConn.selected) {
                    multConn.selected = true;
                }
            });

            // Select parent-sibling connections within rectangle
            parentSiblingConnections.forEach(psConn => {
                // Check if the child target or parent source is within the selection
                let shouldSelect = false;

                // Check parent source
                if (psConn.parentSource.type === 'marriage' || psConn.parentSource.type === 'consanguineous') {
                    const parent1 = psConn.parentSource.from;
                    const parent2 = psConn.parentSource.to;
                    shouldSelect = (parent1.x >= left && parent1.x <= right && parent1.y >= top && parent1.y <= bottom) ||
                                   (parent2.x >= left && parent2.x <= right && parent2.y >= top && parent2.y <= bottom);
                } else {
                    shouldSelect = psConn.parentSource.x >= left && psConn.parentSource.x <= right &&
                                   psConn.parentSource.y >= top && psConn.parentSource.y <= bottom;
                }

                // Check child target
                if (!shouldSelect) {
                    if (psConn.childTarget.type === 'sibling') {
                        shouldSelect = psConn.childTarget.siblings.some(sib =>
                            sib.x >= left && sib.x <= right && sib.y >= top && sib.y <= bottom
                        );
                    } else if (psConn.childTarget.type === 'multiples') {
                        shouldSelect = psConn.childTarget.multiples.some(mult =>
                            mult.x >= left && mult.x <= right && mult.y >= top && mult.y <= bottom
                        );
                    } else {
                        shouldSelect = psConn.childTarget.x >= left && psConn.childTarget.x <= right &&
                                       psConn.childTarget.y >= top && psConn.childTarget.y <= bottom;
                    }
                }

                if (shouldSelect && !psConn.selected) {
                    psConn.selected = true;
                }
            });
        }
        
        // Helper function to check if a line intersects a rectangle
        function lineIntersectsRectangle(connection, left, top, right, bottom) {
            const x1 = connection.from.x;
            const y1 = connection.from.y;
            const x2 = connection.to.x;
            const y2 = connection.to.y;
            
            // Check if line intersects any of the rectangle edges
            return lineIntersectsLine(x1, y1, x2, y2, left, top, right, top) ||     // top edge
                   lineIntersectsLine(x1, y1, x2, y2, right, top, right, bottom) ||  // right edge
                   lineIntersectsLine(x1, y1, x2, y2, right, bottom, left, bottom) || // bottom edge
                   lineIntersectsLine(x1, y1, x2, y2, left, bottom, left, top);      // left edge
        }
        
        // Helper function to check if two lines intersect
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (denom === 0) return false; // parallel lines
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }
        
        function connectSelectedAsMarriage() {
            if (selectedIndividuals.length !== 2) return;
            
            // Save state before making connection
            saveState();
            
            const individual1 = selectedIndividuals[0];
            const individual2 = selectedIndividuals[1];
            
            // Check if connection already exists
            const existingConnection = connections.find(conn =>
                conn.type === 'marriage' && 
                ((conn.from === individual1 && conn.to === individual2) ||
                 (conn.from === individual2 && conn.to === individual1))
            );
            
            if (!existingConnection) {
                const connection = new Connection(individual1, individual2, 'marriage');
                connections.push(connection);
            }
            
            // Clear selections
            selectedIndividuals.forEach(ind => ind.selected = false);
            selectedIndividuals = [];
            
            draw();
        }
        
        function connectSelectedAsConsanguineous() {
            if (selectedIndividuals.length !== 2) return;

            // Save state before making connection
            saveState();

            const individual1 = selectedIndividuals[0];
            const individual2 = selectedIndividuals[1];

            // Check if connection already exists
            const existingConnection = connections.find(conn =>
                conn.type === 'consanguineous' &&
                ((conn.from === individual1 && conn.to === individual2) ||
                 (conn.from === individual2 && conn.to === individual1))
            );

            if (!existingConnection) {
                const connection = new Connection(individual1, individual2, 'consanguineous');
                connections.push(connection);
            }

            // Clear selections
            selectedIndividuals.forEach(ind => ind.selected = false);
            selectedIndividuals = [];

            draw();
        }

        function connectSelectedAsIdentical() {
            if (selectedIndividuals.length !== 2) {
                showCustomAlert("Please select exactly 2 individuals to connect as identical");
                return;
            }

            // Save state before making connection
            saveState();

            const individual1 = selectedIndividuals[0];
            const individual2 = selectedIndividuals[1];

            // Check if they are on the same generation (same y coordinate)
            if (Math.abs(individual1.y - individual2.y) > SNAP_THRESHOLD) {
                showCustomAlert("Identical connections can only be made between symbols on the same generation line");
                selectedIndividuals.forEach(ind => ind.selected = false);
                selectedIndividuals = [];
                draw();
                return;
            }

            // Check if connection already exists
            const existingConnection = connections.find(conn =>
                conn.type === 'identical' &&
                ((conn.from === individual1 && conn.to === individual2) ||
                 (conn.from === individual2 && conn.to === individual1))
            );

            if (!existingConnection) {
                const connection = new Connection(individual1, individual2, 'identical');
                connections.push(connection);
            }

            // Clear selections
            selectedIndividuals.forEach(ind => ind.selected = false);
            selectedIndividuals = [];

            draw();
        }

        function connectSelectedAsSiblings() {
            if (selectedIndividuals.length < 2) {
                showCustomAlert("Please select at least 2 individuals on the same generation to connect as siblings");
                return;
            }

            // Save state before making connection
            saveState();

            // Ensure all selected individuals are on the same generation
            const selectedGeneration = selectedIndividuals[0].y;
            const allSameGeneration = selectedIndividuals.every(ind =>
                Math.abs(ind.y - selectedGeneration) < SNAP_THRESHOLD
            );

            if (!allSameGeneration) {
                showCustomAlert("All siblings must be on the same generation");
                return;
            }

            // Check if a sibling connection already exists for any of these individuals
            const existingConnection = siblingConnections.find(sibConn => {
                // Check if any selected individual is in this sibling group
                return selectedIndividuals.some(selected =>
                    sibConn.siblings.includes(selected)
                );
            });

            if (existingConnection) {
                // Merge with existing sibling group
                const newSiblings = [...new Set([...existingConnection.siblings, ...selectedIndividuals])];
                existingConnection.siblings = newSiblings;
            } else {
                // Create new sibling connection
                const siblingConnection = new SiblingConnection(selectedIndividuals);
                siblingConnections.push(siblingConnection);
            }

            // Clear selections
            selectedIndividuals.forEach(ind => ind.selected = false);
            selectedIndividuals = [];

            draw();
        }

        function connectSelectedAsMultiples() {
            if (selectedIndividuals.length < 2) {
                showCustomAlert("Please select at least 2 individuals on the same generation to connect as multiples (twins, triplets, etc.)");
                return;
            }

            // Save state before making connection
            saveState();

            // Ensure all selected individuals are on the same generation
            const selectedGeneration = selectedIndividuals[0].y;
            const allSameGeneration = selectedIndividuals.every(ind =>
                Math.abs(ind.y - selectedGeneration) < SNAP_THRESHOLD
            );

            if (!allSameGeneration) {
                showCustomAlert("All multiples must be on the same generation");
                return;
            }

            // Check if a multiples connection already exists for any of these individuals
            const existingConnection = multiplesConnections.find(multConn => {
                // Check if any selected individual is in this multiples group
                return selectedIndividuals.some(selected =>
                    multConn.multiples.includes(selected)
                );
            });

            if (existingConnection) {
                // Merge with existing multiples group
                const newMultiples = [...new Set([...existingConnection.multiples, ...selectedIndividuals])];
                existingConnection.multiples = newMultiples;
            } else {
                // Create new multiples connection
                const multiplesConnection = new MultiplesConnection(selectedIndividuals);
                multiplesConnections.push(multiplesConnection);
            }

            // Clear selections
            selectedIndividuals.forEach(ind => ind.selected = false);
            selectedIndividuals = [];

            draw();
        }

        // Helper function to show custom alert
        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-blue-600 text-white hover:bg-blue-700 rounded text-base" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function handleTouchStart(event) {
            event.preventDefault();
            handleMouseDown(event);
        }

        function handleTouchMove(event) {
            event.preventDefault();
            handleMouseMove(event);
        }

        function handleTouchEnd(event) {
            event.preventDefault();
            handleMouseUp(event);
        }

        function handleRightClick(event) {
            event.preventDefault(); // Prevent default context menu
            
            const coords = getCanvasCoordinates(event);
            const clickedItem = findItemAt(coords.x, coords.y);
            
            if (clickedItem) {
                // Show symbol context menu for items
                showSymbolContextMenu(clickedItem, event);
            } else {
                // Show placement context menu for empty space
                showContextMenu(coords.x, coords.y, event);
            }
        }

        function showContextMenu(canvasX, canvasY, originalEvent) {
            // Remove any existing context menu
            const existingMenu = document.getElementById('contextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const contextMenu = document.createElement('div');
            contextMenu.id = 'contextMenu';
            contextMenu.className = 'fixed bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg z-50 py-2 min-w-[160px]';
            
            // Context menu options
            const menuItems = [
                { label: 'Add Male ‚óª', icon: '‚óª', action: () => addSymbolFromContext(canvasX, canvasY, 'male') },
                { label: 'Add Female ‚óã', icon: '‚óã', action: () => addSymbolFromContext(canvasX, canvasY, 'female') },
                { label: 'Add Unknown ‚óá', icon: '‚óá', action: () => addSymbolFromContext(canvasX, canvasY, 'unknown') },
                { label: 'Add Miscarriage ‚ñ≥', icon: '‚ñ≥', action: () => addSymbolFromContext(canvasX, canvasY, 'miscarriage') },
                { label: 'Add Pregnancy ‚óáP', icon: '‚óáP', action: () => addSymbolFromContext(canvasX, canvasY, 'pregnancy') },
                { label: 'Add Ectopic Pregnancy ‚óè', icon: '‚óè', action: () => addSymbolFromContext(canvasX, canvasY, 'ectopic') },
                { label: 'Add TAB ‚ñ≥/', icon: '‚ñ≥/', action: () => addSymbolFromContext(canvasX, canvasY, 'tab') },
                { label: 'Add Text Box üìù', icon: '    ', action: () => addSymbolFromContext(canvasX, canvasY, 'textbox') }
            ];
            
            menuItems.forEach((item, index) => {
                const menuItem = document.createElement('div');
                menuItem.className = 'px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer flex items-center space-x-2 text-sm';
                menuItem.innerHTML = `
                    <span class="text-gray-500 dark:text-gray-400">${item.icon}</span>
                    <span>${item.label}</span>
                `;
                
                menuItem.addEventListener('click', () => {
                    item.action();
                    contextMenu.remove();
                });
                
                contextMenu.appendChild(menuItem);
            });
            
            // Position the context menu
            document.body.appendChild(contextMenu);
            
            // Calculate position relative to viewport
            const rect = canvas.getBoundingClientRect();
            const viewportX = originalEvent.clientX;
            const viewportY = originalEvent.clientY;
            
            // Get menu dimensions
            const menuRect = contextMenu.getBoundingClientRect();
            
            // Adjust position if menu would go off screen
            let finalX = viewportX;
            let finalY = viewportY;
            
            if (finalX + menuRect.width > window.innerWidth) {
                finalX = window.innerWidth - menuRect.width - 10;
            }
            
            if (finalY + menuRect.height > window.innerHeight) {
                finalY = window.innerHeight - menuRect.height - 10;
            }
            
            contextMenu.style.left = `${finalX}px`;
            contextMenu.style.top = `${finalY}px`;
            
            // Close menu when clicking elsewhere
            const closeMenu = (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                    document.removeEventListener('contextmenu', closeMenu);
                }
            };
            
            // Add slight delay to prevent immediate closure
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
                document.addEventListener('contextmenu', closeMenu);
            }, 100);
        }

        function showSymbolContextMenu(item, originalEvent) {
            // Remove any existing context menu
            const existingMenu = document.getElementById('contextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const contextMenu = document.createElement('div');
            contextMenu.id = 'contextMenu';
            contextMenu.className = 'fixed bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg z-50 py-2 min-w-[120px]';
            
            // Get item type for display
            let itemType = 'Item';
            if (item instanceof Individual) {
                const typeNames = { 'male': 'Male', 'female': 'Female', 'unknown': 'Unknown', 'miscarriage': 'Miscarriage' };
                itemType = typeNames[item.type] || 'Individual';
            } else if (item instanceof Connection) {
                itemType = 'Connection';
            } else if (item instanceof TextBox) {
                itemType = 'Text Box';
            }
            
            // Context menu options
            const menuItems = [
                { 
                    label: `Delete ${itemType}`, 
                    icon: 'üóëÔ∏è', 
                    action: () => deleteSpecificItem(item),
                    className: 'text-red-600 dark:text-red-400'
                }
            ];
            
            // Add copy option for all items
            menuItems.unshift({
                label: 'Copy',
                icon: 'üìã',
                action: () => {
                    // Select the item first if it's not already selected
                    if (!item.selected) {
                        // Clear other selections
                        individuals.forEach(ind => ind.selected = false);
                        connections.forEach(conn => conn.selected = false);
                        textBoxes.forEach(tb => tb.selected = false);
                        selectedIndividuals = [];
                        
                        // Select this item
                        item.selected = true;
                        if (item instanceof Individual) {
                            selectedIndividuals.push(item);
                        }
                    }
                    copySelected();
                },
                className: ''
            });

            // Add pregnancy-specific options
            if (item instanceof Individual && item.type === 'pregnancy') {
                // Add donor options for pregnancy symbols
                menuItems.unshift({
                    label: 'Add Egg Donor',
                    icon: '‚óãD',
                    action: () => addDonorToPregnancy(item, 'egg'),
                    className: 'text-pink-600 dark:text-pink-400'
                });
                
                menuItems.unshift({
                    label: 'Add Sperm Donor',
                    icon: '‚óªD',
                    action: () => addDonorToPregnancy(item, 'sperm'),
                    className: 'text-blue-600 dark:text-blue-400'
                });
                
                menuItems.unshift({
                    label: 'Edit Individual',
                    icon: '‚úèÔ∏è',
                    action: () => openInfoModal(item),
                    className: ''
                });
            } else if (item instanceof Individual) {
                menuItems.unshift({
                    label: 'Edit Individual',
                    icon: '‚úèÔ∏è',
                    action: () => openInfoModal(item),
                    className: ''
                });
            } else if (item instanceof TextBox) {
                menuItems.unshift({
                    label: 'Edit Text Box',
                    icon: '‚úèÔ∏è',
                    action: () => openTextBoxModal(item),
                    className: ''
                });
            }
            
            menuItems.forEach((menuItem) => {
                const menuElement = document.createElement('div');
                menuElement.className = `px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer flex items-center space-x-2 text-sm ${menuItem.className}`;
                menuElement.innerHTML = `
                    <span>${menuItem.icon}</span>
                    <span>${menuItem.label}</span>
                `;
                
                menuElement.addEventListener('click', () => {
                    menuItem.action();
                    contextMenu.remove();
                });
                
                contextMenu.appendChild(menuElement);
            });
            
            // Position the context menu
            document.body.appendChild(contextMenu);
            
            // Calculate position relative to viewport
            const viewportX = originalEvent.clientX;
            const viewportY = originalEvent.clientY;
            
            // Get menu dimensions
            const menuRect = contextMenu.getBoundingClientRect();
            
            // Adjust position if menu would go off screen
            let finalX = viewportX;
            let finalY = viewportY;
            
            if (finalX + menuRect.width > window.innerWidth) {
                finalX = window.innerWidth - menuRect.width - 10;
            }
            
            if (finalY + menuRect.height > window.innerHeight) {
                finalY = window.innerHeight - menuRect.height - 10;
            }
            
            contextMenu.style.left = `${finalX}px`;
            contextMenu.style.top = `${finalY}px`;
            
            // Close menu when clicking elsewhere
            const closeMenu = (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                    document.removeEventListener('contextmenu', closeMenu);
                }
            };
            
            // Add slight delay to prevent immediate closure
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
                document.addEventListener('contextmenu', closeMenu);
            }, 100);
        }

        function deleteSpecificItem(item) {
            // Save state before deletion
            saveState();
            
            if (item instanceof Individual) {
                // Remove the individual
                individuals = individuals.filter(ind => ind !== item);
                selectedIndividuals = selectedIndividuals.filter(ind => ind !== item);
                
                // Remove any connections that reference this individual
                connections = connections.filter(conn => 
                    conn.from !== item && conn.to !== item
                );
            } else if (item instanceof Connection) {
                // Remove the connection
                connections = connections.filter(conn => conn !== item);
            } else if (item instanceof TextBox) {
                // Remove the text box
                textBoxes = textBoxes.filter(tb => tb !== item);
            }
            
            // Clear selection states
            individuals.forEach(ind => ind.selected = false);
            connections.forEach(conn => conn.selected = false);
            textBoxes.forEach(tb => tb.selected = false);
            selectedIndividuals = [];
            
            draw();
        }

        function addSymbolFromContext(x, y, type) {
            // Save state before adding
            saveState();
            
            if (type === 'textbox') {
                const id = Date.now();
                const textBox = new TextBox(x, y, 'Double-click to edit', id);
                textBoxes.push(textBox);
            } else {
                const snappedY = snapToLine(y);
                const id = Date.now();
                const individual = new Individual(x, snappedY, type, id);
                individuals.push(individual);
            }
            
            draw();
        }

        // Helper function to find the next generation line
        function findNextGeneration(currentY) {
            // Find the generation line that is below the current Y position
            for (let i = 0; i < SNAP_LINES.length; i++) {
                if (SNAP_LINES[i] > currentY + SNAP_THRESHOLD) {
                    return SNAP_LINES[i];
                }
            }
            
            // If no generation line is found below, create a new one below the last line
            const lastLine = SNAP_LINES[SNAP_LINES.length - 1];
            return lastLine + 150; // Standard spacing between generations
        }

        // Brief message display function
        function showBriefMessage(message) {
            // Create a temporary toast message
            const toast = document.createElement('div');
            toast.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 text-sm';
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // Animate in
            toast.style.transform = 'translateX(100%)';
            toast.style.transition = 'transform 0.3s ease-in-out';
            
            setTimeout(() => {
                toast.style.transform = 'translateX(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // Save and Load Canvas Functions
        function saveCanvas() {
            try {
                // Prepare the canvas state for saving
                const canvasState = {
                    version: "1.0",
                    created: new Date().toISOString(),
                    individuals: individuals.map(ind => ({
                        ...ind,
                        id: ind.id // Ensure ID is included
                    })),
                    connections: connections.map(conn => ({
                        ...conn,
                        fromId: conn.from.id,
                        toId: conn.to.id,
                        // Remove the actual object references for JSON serialization
                        from: undefined,
                        to: undefined
                    })),
                    siblingConnections: siblingConnections.map(sibConn => ({
                        type: 'sibling',
                        siblingIds: sibConn.siblings.map(sib => sib.id),
                        selected: sibConn.selected
                    })),
                    multiplesConnections: multiplesConnections.map(multConn => ({
                        type: 'multiples',
                        multipleIds: multConn.multiples.map(mult => mult.id),
                        selected: multConn.selected
                    })),
                    textBoxes: textBoxes.map(tb => ({ ...tb })),
                    probandArrows: probandArrows.map(arrow => ({ ...arrow })),
                    patternDefinitions: patternDefinitions.map(pattern => ({ ...pattern }))
                };
                
                // Convert to JSON string
                const jsonString = JSON.stringify(canvasState, null, 2);
                
                // Create blob and download
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `family-tree-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up
                URL.revokeObjectURL(url);
                
                showBriefMessage('Canvas saved successfully!');
                
            } catch (error) {
                console.error('Error saving canvas:', error);
                showCustomAlert('Error saving canvas. Please try again.');
            }
        }

        function loadCanvas() {
            // Trigger file input click
            const fileInput = document.getElementById('loadFileInput');
            fileInput.click();
        }

        function loadCanvasFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Enhanced file validation
            if (!file.name.endsWith('.json')) {
                showCustomAlert('Please select a valid JSON file.');
                return;
            }
            
            // Check file size (limit to 10MB)
            if (file.size > 10 * 1024 * 1024) {
                showCustomAlert('File is too large. Please select a file smaller than 10MB.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    
                    // Basic content validation
                    if (typeof content !== 'string' || content.length === 0) {
                        throw new Error('Invalid file content');
                    }
                    
                    const canvasState = JSON.parse(content);
                    
                    // Validate required structure
                    if (!canvasState || typeof canvasState !== 'object') {
                        throw new Error('Invalid canvas file format: not a valid object');
                    }
                    
                    // Validate the loaded data
                    if (!canvasState.individuals || !Array.isArray(canvasState.individuals)) {
                        throw new Error('Invalid canvas file format: missing individuals data');
                    }
                    
                    // Save current state to undo history before loading
                    saveState();
                    
                    // Clear current canvas
                    individuals = [];
                    connections = [];
                    siblingConnections = [];
                    multiplesConnections = [];
                    textBoxes = [];
                    probandArrows = [];
                    patternDefinitions = [];
                    selectedIndividuals = [];
                    
                    // Restore individuals
                    canvasState.individuals.forEach(indData => {
                        const individual = new Individual(indData.x, indData.y, indData.type, indData.id);
                        // Copy all properties
                        Object.assign(individual, indData);
                        individual.selected = false; // Ensure no items are selected after load
                        individuals.push(individual);
                    });
                    
                    // Restore pattern definitions if they exist
                    if (canvasState.patternDefinitions && Array.isArray(canvasState.patternDefinitions)) {
                        patternDefinitions = [...canvasState.patternDefinitions];
                        patternCounter = Math.max(0, ...patternDefinitions.map(p => {
                            const match = p.id.match(/pattern_(\d+)/);
                            return match ? parseInt(match[1]) : 0;
                        }));
                    }
                    
                    // Restore connections
                    if (canvasState.connections && Array.isArray(canvasState.connections)) {
                        canvasState.connections.forEach(connData => {
                            // Find the individual objects by ID
                            const fromInd = individuals.find(ind => ind.id === connData.fromId);
                            const toInd = individuals.find(ind => ind.id === connData.toId);

                            if (fromInd && toInd) {
                                const connection = new Connection(fromInd, toInd, connData.type);
                                connection.selected = false;
                                // Restore custom position properties if they exist
                                if (connData.customYOffset !== undefined) {
                                    connection.customYOffset = connData.customYOffset;
                                }
                                if (connData.hasCustomPosition !== undefined) {
                                    connection.hasCustomPosition = connData.hasCustomPosition;
                                }
                                connections.push(connection);
                            }
                        });
                    }

                    // Restore sibling connections
                    if (canvasState.siblingConnections && Array.isArray(canvasState.siblingConnections)) {
                        canvasState.siblingConnections.forEach(sibConnData => {
                            // Find the individual objects by ID
                            const siblings = sibConnData.siblingIds
                                .map(id => individuals.find(ind => ind.id === id))
                                .filter(ind => ind !== undefined);

                            if (siblings.length >= 2) {
                                const siblingConnection = new SiblingConnection(siblings);
                                siblingConnection.selected = false;
                                siblingConnections.push(siblingConnection);
                            }
                        });
                    }

                    // Restore multiples connections
                    if (canvasState.multiplesConnections && Array.isArray(canvasState.multiplesConnections)) {
                        canvasState.multiplesConnections.forEach(multConnData => {
                            // Find the individual objects by ID
                            const multiples = multConnData.multipleIds
                                .map(id => individuals.find(ind => ind.id === id))
                                .filter(ind => ind !== undefined);

                            if (multiples.length >= 2) {
                                const multiplesConnection = new MultiplesConnection(multiples);
                                multiplesConnection.selected = false;
                                multiplesConnections.push(multiplesConnection);
                            }
                        });
                    }

                    // Restore text boxes
                    if (canvasState.textBoxes && Array.isArray(canvasState.textBoxes)) {
                        canvasState.textBoxes.forEach(tbData => {
                            const textBox = new TextBox(tbData.x, tbData.y, tbData.text, tbData.id);
                            Object.assign(textBox, tbData);
                            textBox.selected = false;
                            textBoxes.push(textBox);
                        });
                    }
                    
                    // Restore proband arrows
                    if (canvasState.probandArrows && Array.isArray(canvasState.probandArrows)) {
                        canvasState.probandArrows.forEach(arrowData => {
                            const arrow = new ProbanadArrow(arrowData.x, arrowData.y, arrowData.id);
                            Object.assign(arrow, arrowData);
                            arrow.selected = false;
                            probandArrows.push(arrow);
                        });
                    }
                    
                    // Update UI elements
                    updateUndoButton();
                    updatePasteButton();
                    updateFamilyConnectionButton();
                    renderPatternList();
                    updateEmptyMessage();
                    updateDisorderDropdowns();
                    
                    // Redraw canvas
                    draw();
                    
                    showBriefMessage(`Canvas loaded successfully! Restored ${individuals.length} individuals, ${connections.length} connections, and ${textBoxes.length} text boxes.`);
                    
                } catch (error) {
                    console.error('Error loading canvas:', error);
                    showCustomAlert(`Error loading canvas file: ${error.message}`);
                }
            };
            
            reader.onerror = function() {
                showCustomAlert('Error reading file. Please try again.');
            };
            
            reader.readAsText(file);
            
            // Reset file input so the same file can be loaded again if needed
            event.target.value = '';
        }

        function handleDoubleClick(event) {
            const coords = getCanvasCoordinates(event);
            const textBox = textBoxes.find(tb => tb.contains(coords.x, coords.y));
            const individual = individuals.find(ind => ind.contains(coords.x, coords.y));
            
            if (textBox) {
                openTextBoxModal(textBox);
            } else if (individual) {
                if (individual.type === 'pregnancy') {
                    openPregnancyModal(individual);
                } else if (individual.type === 'miscarriage') {
                    openMiscarriageModal(individual);
                } else if (individual.type === 'tab') {
                    openTabModal(individual);
                } else if (individual.type === 'ectopic') {
                    openEctopicModal(individual);
                } else {
                    openInfoModal(individual);
                }
            }
        }

        function snapToLine(y) {
            let closestLine = y;
            let minDistance = SNAP_THRESHOLD;
            
            for (let line of SNAP_LINES) {
                const distance = Math.abs(y - line);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestLine = line;
                }
            }
            
            return closestLine;
        }

        // Undo System Functions
        function saveState() {
            try {
                // Create a deep copy of the current state
                const state = {
                    individuals: individuals.map(ind => ({ ...ind })),
                    textBoxes: textBoxes.map(tb => ({ ...tb })),
                    probandArrows: probandArrows.map(arrow => ({ ...arrow })),
                    separationSymbols: separationSymbols.map(symbol => ({ ...symbol }))
                };
                
                undoHistory.push(state);
                
                // Limit history size to prevent memory issues
                if (undoHistory.length > maxHistorySize) {
                    undoHistory.shift(); // Remove oldest state
                }
                
                // Update undo button state
                updateUndoButton();
            } catch (error) {
                console.error('Error saving state:', error);
                // Continue operation even if state save fails
            }
        }
        
        function undoLastAction() {
            if (undoHistory.length === 0) return;
            
            // Get the last saved state
            const lastState = undoHistory.pop();
            
            // Restore the state
            individuals = lastState.individuals.map(indData => {
                const ind = new Individual(indData.x, indData.y, indData.type, indData.id);
                // Copy all properties
                Object.assign(ind, indData);
                return ind;
            });
            
            // Note: Connection system has been removed from this application
            
            textBoxes = lastState.textBoxes.map(tbData => {
                const tb = new TextBox(tbData.x, tbData.y, tbData.text, tbData.id);
                // Copy all properties
                Object.assign(tb, tbData);
                return tb;
            });
            
            // Restore proband arrows if they exist in the state
            if (lastState.probandArrows) {
                probandArrows = lastState.probandArrows.map(arrowData => {
                    const arrow = new ProbanadArrow(arrowData.x, arrowData.y, arrowData.id);
                    Object.assign(arrow, arrowData);
                    return arrow;
                });
            } else {
                probandArrows = [];
            }
            
            // Restore separation symbols if they exist in the state
            if (lastState.separationSymbols) {
                separationSymbols = lastState.separationSymbols.map(symbolData => {
                    const symbol = new SeparationSymbol(symbolData.x, symbolData.y, symbolData.id);
                    Object.assign(symbol, symbolData);
                    return symbol;
                });
            } else {
                separationSymbols = [];
            }
            
            // Clear selections
            individuals.forEach(ind => ind.selected = false);
            connections.forEach(conn => conn.selected = false);
            textBoxes.forEach(tb => tb.selected = false);
            probandArrows.forEach(arrow => arrow.selected = false);
            separationSymbols.forEach(symbol => symbol.selected = false);
            selectedIndividuals = [];
            
            // Update undo button state
            updateUndoButton();
            
            // Redraw
            draw();
        }
        
        function updateUndoButton() {
            const undoBtn = document.getElementById('btn-undo');
            if (undoHistory.length > 0) {
                undoBtn.disabled = false;
                undoBtn.title = `Undo last action (${undoHistory.length} actions available)`;
            } else {
                undoBtn.disabled = true;
                undoBtn.title = 'No actions to undo';
            }
        }

        function addIndividual(x, y, type) {
            // Save state before adding
            saveState();
            
            const snappedY = snapToLine(y);
            const id = Date.now();
            const individual = new Individual(x, snappedY, type, id);
            individuals.push(individual);
            draw();
        }

        function addTextBox(x, y) {
            // Save state before adding
            saveState();
            
            const id = Date.now();
            const textBox = new TextBox(x, y, '', id); // Start with empty text
            textBoxes.push(textBox);
            
            // Immediately open the text box modal for editing
            openTextBoxModal(textBox);
        }

        // Text Box Modal Functions
        function openTextBoxModal(textBox) {
            currentTextBoxId = textBox.id;
            const textArea = document.getElementById('textBoxContent');
            textArea.value = textBox.text;
            document.getElementById('textBoxFontSize').value = textBox.fontSize;
            
            // Update character count
            updateCharCount();
            
            // Add event listener for character counting
            textArea.addEventListener('input', updateCharCount);
            
            document.getElementById('textBoxModal').classList.remove('hidden');
        }

        function updateCharCount() {
            const textArea = document.getElementById('textBoxContent');
            const charCount = document.getElementById('charCount');
            const currentLength = textArea.value.length;
            charCount.textContent = `${currentLength}/300`;
            
            // Change color when approaching limit
            if (currentLength > 280) {
                charCount.classList.add('text-red-500');
                charCount.classList.remove('text-gray-500');
            } else if (currentLength > 250) {
                charCount.classList.add('text-yellow-500');
                charCount.classList.remove('text-gray-500', 'text-red-500');
            } else {
                charCount.classList.add('text-gray-500');
                charCount.classList.remove('text-red-500', 'text-yellow-500');
            }
        }

        function closeTextBoxModal() {
            document.getElementById('textBoxModal').classList.add('hidden');
            currentTextBoxId = null;
        }

        function saveTextBoxInfo() {
            if (currentTextBoxId) {
                const textBox = textBoxes.find(tb => tb.id === currentTextBoxId);
                if (textBox) {
                    // Save state before making changes
                    saveState();
                    
                    textBox.text = document.getElementById('textBoxContent').value || 'Empty text box';
                    textBox.fontSize = parseInt(document.getElementById('textBoxFontSize').value);
                    
                    // Deselect the text box to hide visual elements
                    textBox.selected = false;
                    
                    draw();
                }
            }
            closeTextBoxModal();
        }

        function selectItem(x, y) {
            // Clear all selections first
            individuals.forEach(ind => ind.selected = false);
            connections.forEach(conn => conn.selected = false);
            
            const item = findItemAt(x, y);
            if (item) {
                item.selected = true;
            }
            
            draw();
        }

        function addProbandArrow(x, y) {
            // Save state before adding
            saveState();
            
            const id = Date.now();
            const probandArrow = new ProbanadArrow(x, y, id);
            probandArrows.push(probandArrow);
            draw();
        }

        function addSeparationSymbol(x, y) {
            // Save state before adding
            saveState();
            
            const id = Date.now();
            const separationSymbol = new SeparationSymbol(x, y, id);
            separationSymbols.push(separationSymbol);
            draw();
        }

        function findItemAt(x, y) {
            // Check separation symbols first
            for (let separationSymbol of separationSymbols) {
                if (separationSymbol.contains(x, y)) {
                    return separationSymbol;
                }
            }

            // Check proband arrows
            for (let probandArrow of probandArrows) {
                if (probandArrow.contains(x, y)) {
                    return probandArrow;
                }
            }

            // Check text boxes (they're drawn on top)
            for (let textBox of textBoxes) {
                if (textBox.contains(x, y)) {
                    return textBox;
                }
            }

            // Check parent-sibling connections
            for (let parentSiblingConnection of parentSiblingConnections) {
                if (parentSiblingConnection.contains(x, y)) {
                    return parentSiblingConnection;
                }
            }

            // Check sibling connections
            for (let siblingConnection of siblingConnections) {
                if (siblingConnection.contains(x, y)) {
                    return siblingConnection;
                }
            }

            // Check multiples connections
            for (let multiplesConnection of multiplesConnections) {
                if (multiplesConnection.contains(x, y)) {
                    return multiplesConnection;
                }
            }

            // Check connections
            for (let connection of connections) {
                if (connection.contains(x, y)) {
                    return connection;
                }
            }

            // Check individuals
            for (let individual of individuals) {
                if (individual.contains(x, y)) {
                    return individual;
                }
            }

            return null;
        }

        function handleConnection(x, y) {
            const individual = individuals.find(ind => ind.contains(x, y));
            
            if (!individual) return;
            
            if (!connectingFrom) {
                connectingFrom = individual;
                individual.selected = true;
                draw();
            } else if (connectingFrom !== individual) {
                // Check if connection already exists
                const existingConnection = connections.find(conn =>
                    (conn.from === connectingFrom && conn.to === individual && conn.type === currentTool) ||
                    (conn.from === individual && conn.to === connectingFrom && conn.type === currentTool)
                );
                
                if (!existingConnection) {
                    const connection = new Connection(connectingFrom, individual, currentTool);
                    connections.push(connection);
                }
                
                connectingFrom.selected = false;
                connectingFrom = null;
                draw();
            }
        }

        function deleteSelected() {
            // Save state before deletion
            saveState();

            // Get list of individuals being deleted
            const deletedIndividuals = individuals.filter(ind => ind.selected);

            individuals = individuals.filter(ind => !ind.selected);
            textBoxes = textBoxes.filter(tb => !tb.selected);

            // Remove selected connections
            connections = connections.filter(conn => !conn.selected);

            // Remove connections that reference deleted individuals
            connections = connections.filter(conn =>
                !deletedIndividuals.includes(conn.from) && !deletedIndividuals.includes(conn.to)
            );

            // Also filter proband arrows and separation symbols
            probandArrows = probandArrows.filter(arrow => !arrow.selected);
            separationSymbols = separationSymbols.filter(symbol => !symbol.selected);

            // Filter sibling connections - remove those that reference deleted individuals
            siblingConnections = siblingConnections.filter(sibConn => {
                // Remove deleted individuals from sibling group
                sibConn.siblings = sibConn.siblings.filter(sib => !deletedIndividuals.includes(sib));
                // Only keep sibling connections with 2+ individuals
                return sibConn.siblings.length >= 2;
            });

            // Also remove selected sibling connections
            siblingConnections = siblingConnections.filter(sibConn => !sibConn.selected);

            // Filter multiples connections - remove those that reference deleted individuals
            multiplesConnections = multiplesConnections.filter(multConn => {
                // Remove deleted individuals from multiples group
                multConn.multiples = multConn.multiples.filter(mult => !deletedIndividuals.includes(mult));
                // Only keep multiples connections with 2+ individuals
                return multConn.multiples.length >= 2;
            });

            // Also remove selected multiples connections
            multiplesConnections = multiplesConnections.filter(multConn => !multConn.selected);

            // Filter parent-sibling connections - remove those that reference deleted individuals or connections
            parentSiblingConnections = parentSiblingConnections.filter(psConn => {
                // Check if parentSource still exists
                let parentSourceExists = false;
                if (psConn.parentSource.type === 'marriage' || psConn.parentSource.type === 'consanguineous') {
                    // It's a connection - check if it still exists
                    parentSourceExists = connections.includes(psConn.parentSource);
                } else {
                    // It's an Individual - check if it wasn't deleted
                    parentSourceExists = !deletedIndividuals.includes(psConn.parentSource);
                }

                // Check if childTarget still exists
                let childTargetExists = false;
                if (psConn.childTarget.type === 'sibling') {
                    // It's a sibling connection - check if it still exists
                    childTargetExists = siblingConnections.includes(psConn.childTarget);
                } else if (psConn.childTarget.type === 'multiples') {
                    // It's a multiples connection - check if it still exists
                    childTargetExists = multiplesConnections.includes(psConn.childTarget);
                } else {
                    // It's an Individual - check if it wasn't deleted
                    childTargetExists = !deletedIndividuals.includes(psConn.childTarget);
                }

                return parentSourceExists && childTargetExists && !psConn.selected;
            });

            // Clear all selection state
            selectedIndividuals = [];
            individuals.forEach(ind => ind.selected = false);
            textBoxes.forEach(tb => tb.selected = false);
            connections.forEach(conn => conn.selected = false);
            probandArrows.forEach(arrow => arrow.selected = false);
            separationSymbols.forEach(symbol => symbol.selected = false);
            siblingConnections.forEach(sibConn => sibConn.selected = false);
            multiplesConnections.forEach(multConn => multConn.selected = false);
            parentSiblingConnections.forEach(psConn => psConn.selected = false);

            draw();
        }

        function clearAll() {
            showConfirmDialog("Are you sure you want to clear the entire pedigree?", performClearAll);
        }

        function performClearAll() {
            // Save state before clearing
            saveState();

            // Clear all data arrays
            individuals = [];
            connections = [];
            siblingConnections = [];
            multiplesConnections = [];
            parentSiblingConnections = [];
            textBoxes = [];
            probandArrows = [];
            separationSymbols = [];
            selectedIndividuals = [];
            
            // Clear tool selection and button highlighting
            currentTool = null;
            document.querySelectorAll('button[id^="btn-"]').forEach(btn => {
                btn.classList.remove('selected-symbol');
            });
            
            // Reset canvas cursor
            canvas.style.cursor = 'default';
            
            // Update UI buttons
            updateFamilyConnectionButton();
            updateUndoButton();
            updatePasteButton();
            
            draw();
        }

        function showConfirmDialog(message, onConfirm) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end space-x-3">
                        <button id="cancelBtn" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base">Cancel</button>
                        <button id="confirmBtn" class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded text-base">Confirm</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Add event listeners instead of inline onclick
            const cancelBtn = modal.querySelector('#cancelBtn');
            const confirmBtn = modal.querySelector('#confirmBtn');
            
            cancelBtn.addEventListener('click', () => {
                modal.remove();
            });
            
            confirmBtn.addEventListener('click', () => {
                modal.remove();
                onConfirm();
            });
            
            return true;
        }

        function openInfoModal(individual) {
            currentIndividualId = individual.id;
            
            if (individual.type === 'unknown') {
                openUnknownInfoModal(individual);
            } else {
                openRegularInfoModal(individual);
            }
        }
        
        function openUnknownInfoModal(individual) {
            // Create and show unknown individual modal with specific fields
            createUnknownModal(individual);
        }
        
        function createUnknownModal(individual) {
            // Remove existing unknown modal if it exists
            const existingModal = document.getElementById('unknownInfoModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create the modal HTML
            const modalHTML = `
                <div id="unknownInfoModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg w-full max-w-md max-h-screen overflow-y-auto">
                        <h3 class="text-lg font-semibold mb-4">Unknown Individual Information</h3>
                        <div class="space-y-3">
                            <div>
                                <label class="block text-sm font-medium mb-1">Name:</label>
                                <input type="text" id="unknownName" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-1">Year of Birth:</label>
                                <input type="number" id="unknownBirth" min="1800" max="2100" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="e.g., 1990">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-1">Sex Assignment at Birth:</label>
                                <select id="unknownSexAtBirth" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                                    <option value="">Select...</option>
                                    <option value="AFAB">AFAB (Assigned Female at Birth)</option>
                                    <option value="AMAB">AMAB (Assigned Male at Birth)</option>
                                    <option value="unknown">Unknown</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-1">Current Gender Identity:</label>
                                <select id="unknownGenderIdentity" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base">
                                    <option value="">Select...</option>
                                    <option value="male">Male</option>
                                    <option value="female">Female</option>
                                    <option value="non-binary">Non-binary</option>
                                    <option value="unknown">Unknown</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-1">Comments:</label>
                                <textarea id="unknownComments" rows="3" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" placeholder="Additional information..."></textarea>
                            </div>

                            <!-- Disorder Patterns -->
                            <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                                <label class="block text-sm font-medium mb-2">Disorder Patterns by Quadrant:</label>
                                <div class="grid grid-cols-2 gap-3">
                                    <div>
                                        <label class="block text-xs mb-1">Top-Left:</label>
                                        <select id="unknownDisorderTL" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                            <option value="">None</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="block text-xs mb-1">Top-Right:</label>
                                        <select id="unknownDisorderTR" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                            <option value="">None</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="block text-xs mb-1">Bottom-Left:</label>
                                        <select id="unknownDisorderBL" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                            <option value="">None</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="block text-xs mb-1">Bottom-Right:</label>
                                        <select id="unknownDisorderBR" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                            <option value="">None</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <!-- Display Options -->
                            <div class="border-t border-gray-200 dark:border-gray-600 pt-3 mt-3">
                                <label class="block text-sm font-medium mb-2">Display Options:</label>
                                <div class="space-y-2">
                                    <label class="flex items-center">
                                        <input type="checkbox" id="showUnknownName" class="mr-2">
                                        <span class="text-sm">Show Name</span>
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" id="showUnknownBirth" class="mr-2">
                                        <span class="text-sm">Show Birth Year</span>
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" id="showUnknownSexAtBirth" class="mr-2">
                                        <span class="text-sm">Show Sex Assignment at Birth</span>
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" id="showUnknownGenderIdentity" class="mr-2">
                                        <span class="text-sm">Show Gender Identity</span>
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" id="showUnknownComments" class="mr-2">
                                        <span class="text-sm">Show Comments</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        <div class="flex justify-end space-x-3 mt-6">
                            <button onclick="closeUnknownModal()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base">Cancel</button>
                            <button onclick="saveUnknownInfo()" class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded text-base">Save</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to document
            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // Populate fields with current individual data
            document.getElementById('unknownName').value = individual.name || '';
            document.getElementById('unknownBirth').value = individual.birth || '';
            document.getElementById('unknownSexAtBirth').value = individual.sexAtBirth || '';
            document.getElementById('unknownGenderIdentity').value = individual.genderIdentity || '';
            document.getElementById('unknownComments').value = individual.comments || '';

            // Update disorder dropdowns with current legend
            updateUnknownDisorderDropdowns();

            // Set current disorder selections
            document.getElementById('unknownDisorderTL').value = individual.disorderTL || '';
            document.getElementById('unknownDisorderTR').value = individual.disorderTR || '';
            document.getElementById('unknownDisorderBL').value = individual.disorderBL || '';
            document.getElementById('unknownDisorderBR').value = individual.disorderBR || '';

            // Set display options
            document.getElementById('showUnknownName').checked = individual.showName || false;
            document.getElementById('showUnknownBirth').checked = individual.showBirth || false;
            document.getElementById('showUnknownSexAtBirth').checked = individual.showSexAtBirth || false;
            document.getElementById('showUnknownGenderIdentity').checked = individual.showGenderIdentity || false;
            document.getElementById('showUnknownComments').checked = individual.showComments || false;
        }
        
        function closeUnknownModal() {
            const modal = document.getElementById('unknownInfoModal');
            if (modal) {
                modal.remove();
            }
            currentIndividualId = null;
        }
        
        function saveUnknownInfo() {
            if (currentIndividualId) {
                const individual = individuals.find(ind => ind.id === currentIndividualId);
                if (individual) {
                    // Save state before making changes
                    saveState();
                    
                    // Get values from the unknown individual form
                    individual.name = document.getElementById('unknownName').value;
                    individual.birth = document.getElementById('unknownBirth').value;
                    individual.sexAtBirth = document.getElementById('unknownSexAtBirth').value;
                    individual.genderIdentity = document.getElementById('unknownGenderIdentity').value;
                    individual.comments = document.getElementById('unknownComments').value;

                    // Save disorder selections
                    individual.disorderTL = document.getElementById('unknownDisorderTL').value;
                    individual.disorderTR = document.getElementById('unknownDisorderTR').value;
                    individual.disorderBL = document.getElementById('unknownDisorderBL').value;
                    individual.disorderBR = document.getElementById('unknownDisorderBR').value;

                    // Set pattern types based on disorder selections
                    individual.patternTL = getPatternForDisease(individual.disorderTL);
                    individual.patternTR = getPatternForDisease(individual.disorderTR);
                    individual.patternBL = getPatternForDisease(individual.disorderBL);
                    individual.patternBR = getPatternForDisease(individual.disorderBR);

                    // Set display options
                    individual.showName = document.getElementById('showUnknownName').checked;
                    individual.showBirth = document.getElementById('showUnknownBirth').checked;
                    individual.showSexAtBirth = document.getElementById('showUnknownSexAtBirth').checked;
                    individual.showGenderIdentity = document.getElementById('showUnknownGenderIdentity').checked;
                    individual.showComments = document.getElementById('showUnknownComments').checked;

                    draw();
                }
            }
            closeUnknownModal();
        }
        
        function openRegularInfoModal(individual) {
            document.getElementById('individualName').value = individual.name;
            document.getElementById('individualBirth').value = individual.birth;
            document.getElementById('individualFillChar').value = individual.fillChar;
            document.getElementById('individualSexAtBirth').value = individual.sexAtBirth || '';
            document.getElementById('individualGenderIdentity').value = individual.genderIdentity || '';
            document.getElementById('individualNotes').value = individual.notes;
            document.getElementById('showName').checked = individual.showName;
            document.getElementById('showBirth').checked = individual.showBirth;
            document.getElementById('showSexAtBirth').checked = individual.showSexAtBirth || false;
            document.getElementById('showGenderIdentity').checked = individual.showGenderIdentity || false;
            document.getElementById('showNotes').checked = individual.showNotes;
            // Update disorder dropdowns with current legend
            updateDisorderDropdowns();

            // Set current disorder selections
            document.getElementById('disorderTL').value = individual.disorderTL || '';
            document.getElementById('disorderTR').value = individual.disorderTR || '';
            document.getElementById('disorderBL').value = individual.disorderBL || '';
            document.getElementById('disorderBR').value = individual.disorderBR || '';

            document.getElementById('infoModal').classList.remove('hidden');
        }

        function closeInfoModal() {
            document.getElementById('infoModal').classList.add('hidden');
            currentIndividualId = null;
        }

        function saveIndividualInfo() {
            if (currentIndividualId) {
                const individual = individuals.find(ind => ind.id === currentIndividualId);
                if (individual) {
                    // Save state before making changes
                    saveState();

                    individual.name = document.getElementById('individualName').value;
                    individual.birth = document.getElementById('individualBirth').value;
                    individual.fillChar = document.getElementById('individualFillChar').value;
                    individual.sexAtBirth = document.getElementById('individualSexAtBirth').value;
                    individual.genderIdentity = document.getElementById('individualGenderIdentity').value;
                    individual.notes = document.getElementById('individualNotes').value;
                    individual.showName = document.getElementById('showName').checked;
                    individual.showBirth = document.getElementById('showBirth').checked;
                    individual.showSexAtBirth = document.getElementById('showSexAtBirth').checked;
                    individual.showGenderIdentity = document.getElementById('showGenderIdentity').checked;
                    individual.showNotes = document.getElementById('showNotes').checked;
                    // Save disorder names (not pattern types)
                    individual.disorderTL = document.getElementById('disorderTL').value;
                    individual.disorderTR = document.getElementById('disorderTR').value;
                    individual.disorderBL = document.getElementById('disorderBL').value;
                    individual.disorderBR = document.getElementById('disorderBR').value;

                    // Update pattern types based on disorder selection
                    individual.patternTL = getPatternForDisease(individual.disorderTL);
                    individual.patternTR = getPatternForDisease(individual.disorderTR);
                    individual.patternBL = getPatternForDisease(individual.disorderBL);
                    individual.patternBR = getPatternForDisease(individual.disorderBR);

                    draw();
                }
            }
            closeInfoModal();
        }

        // TAB Modal Functions
        function openTabModal(tabIndividual) {
            currentIndividualId = tabIndividual.id;
            
            // Set the TAB-specific fields with current values
            document.getElementById('tabGestation').value = tabIndividual.gestation || '';
            document.getElementById('tabReason').value = tabIndividual.reason || '';
            document.getElementById('tabComments').value = tabIndividual.comments || '';
            document.getElementById('showTabGestation').checked = tabIndividual.showGestation || false;
            document.getElementById('showTabReason').checked = tabIndividual.showReason || false;
            document.getElementById('showTabComments').checked = tabIndividual.showComments || false;
            
            document.getElementById('tabModal').classList.remove('hidden');
        }

        function closeTabModal() {
            document.getElementById('tabModal').classList.add('hidden');
            currentIndividualId = null;
        }

        function saveTabInfo() {
            if (currentIndividualId) {
                const tabIndividual = individuals.find(ind => ind.id === currentIndividualId);
                if (tabIndividual) {
                    // Save state before making changes
                    saveState();
                    
                    // Get the TAB-specific values from the inputs
                    tabIndividual.gestation = document.getElementById('tabGestation').value;
                    tabIndividual.reason = document.getElementById('tabReason').value;
                    tabIndividual.comments = document.getElementById('tabComments').value;
                    tabIndividual.showGestation = document.getElementById('showTabGestation').checked;
                    tabIndividual.showReason = document.getElementById('showTabReason').checked;
                    tabIndividual.showComments = document.getElementById('showTabComments').checked;
                    
                    draw();
                }
            }
            closeTabModal();
        }

        // Pregnancy Modal Functions
        function openPregnancyModal(pregnancyIndividual) {
            currentIndividualId = pregnancyIndividual.id;
            
            // Set the LMP and EDC fields with current values (convert from display format back to YYYY-MM-DD if needed)
            document.getElementById('pregnancyLMP').value = convertDisplayToInputDate(pregnancyIndividual.lmp) || '';
            document.getElementById('pregnancyEDC').value = convertDisplayToInputDate(pregnancyIndividual.edc) || '';
            document.getElementById('pregnancyNotes').value = pregnancyIndividual.notes || '';
            document.getElementById('showPregnancyNotes').checked = pregnancyIndividual.showPregnancyNotes || false;
            
            // Set maternal complication checkboxes
            document.getElementById('maternalHypertension').checked = pregnancyIndividual.maternalHypertension || false;
            document.getElementById('maternalPreeclampsia').checked = pregnancyIndividual.maternalPreeclampsia || false;
            document.getElementById('maternalGestationalDiabetes').checked = pregnancyIndividual.maternalGestationalDiabetes || false;
            document.getElementById('maternalIDDM').checked = pregnancyIndividual.maternalIDDM || false;
            document.getElementById('maternalTeratogenicExposure').checked = pregnancyIndividual.maternalTeratogenicExposure || false;
            document.getElementById('maternalPlacentalBleeding').checked = pregnancyIndividual.maternalPlacentalBleeding || false;
            document.getElementById('maternalOther').checked = pregnancyIndividual.maternalOther || false;
            
            // Set fetal complication checkboxes
            document.getElementById('fetalIUGR').checked = pregnancyIndividual.fetalIUGR || false;
            document.getElementById('fetalPosNIPT').checked = pregnancyIndividual.fetalPosNIPT || false;
            document.getElementById('fetalOligoPolyHydramnios').checked = pregnancyIndividual.fetalOligoPolyHydramnios || false;
            document.getElementById('fetal3VesselCord').checked = pregnancyIndividual.fetal3VesselCord || false;
            document.getElementById('fetalSoftSignsUS').checked = pregnancyIndividual.fetalSoftSignsUS || false;
            document.getElementById('fetalOther').checked = pregnancyIndividual.fetalOther || false;
            
            // Set display options
            document.getElementById('showMaternalComplications').checked = pregnancyIndividual.showMaternalComplications || false;
            document.getElementById('showFetalComplications').checked = pregnancyIndividual.showFetalComplications || false;
            
            document.getElementById('pregnancyModal').classList.remove('hidden');
        }

        function closePregnancyModal() {
            document.getElementById('pregnancyModal').classList.add('hidden');
            currentIndividualId = null;
        }

        function savePregnancyInfo() {
            if (currentIndividualId) {
                const pregnancyIndividual = individuals.find(ind => ind.id === currentIndividualId);
                if (pregnancyIndividual) {
                    // Save state before making changes
                    saveState();
                    
                    // Get the date values from the inputs
                    pregnancyIndividual.lmp = document.getElementById('pregnancyLMP').value;
                    pregnancyIndividual.edc = document.getElementById('pregnancyEDC').value;
                    pregnancyIndividual.notes = document.getElementById('pregnancyNotes').value;
                    pregnancyIndividual.showPregnancyNotes = document.getElementById('showPregnancyNotes').checked;
                    
                    // Save maternal complications
                    pregnancyIndividual.maternalHypertension = document.getElementById('maternalHypertension').checked;
                    pregnancyIndividual.maternalPreeclampsia = document.getElementById('maternalPreeclampsia').checked;
                    pregnancyIndividual.maternalGestationalDiabetes = document.getElementById('maternalGestationalDiabetes').checked;
                    pregnancyIndividual.maternalIDDM = document.getElementById('maternalIDDM').checked;
                    pregnancyIndividual.maternalTeratogenicExposure = document.getElementById('maternalTeratogenicExposure').checked;
                    pregnancyIndividual.maternalPlacentalBleeding = document.getElementById('maternalPlacentalBleeding').checked;
                    pregnancyIndividual.maternalOther = document.getElementById('maternalOther').checked;
                    
                    // Save fetal complications
                    pregnancyIndividual.fetalIUGR = document.getElementById('fetalIUGR').checked;
                    pregnancyIndividual.fetalPosNIPT = document.getElementById('fetalPosNIPT').checked;
                    pregnancyIndividual.fetalOligoPolyHydramnios = document.getElementById('fetalOligoPolyHydramnios').checked;
                    pregnancyIndividual.fetal3VesselCord = document.getElementById('fetal3VesselCord').checked;
                    pregnancyIndividual.fetalSoftSignsUS = document.getElementById('fetalSoftSignsUS').checked;
                    pregnancyIndividual.fetalOther = document.getElementById('fetalOther').checked;
                    
                    // Save display options
                    pregnancyIndividual.showMaternalComplications = document.getElementById('showMaternalComplications').checked;
                    pregnancyIndividual.showFetalComplications = document.getElementById('showFetalComplications').checked;
                    
                    // Convert dates to display format if they exist
                    if (pregnancyIndividual.lmp) {
                        pregnancyIndividual.lmp = formatDateForDisplay(pregnancyIndividual.lmp);
                    }
                    if (pregnancyIndividual.edc) {
                        pregnancyIndividual.edc = formatDateForDisplay(pregnancyIndividual.edc);
                    }
                    
                    draw();
                }
            }
            closePregnancyModal();
        }

        // Helper function to format date for display
        function formatDateForDisplay(dateString) {
            if (!dateString) return '';
            
            try {
                const date = new Date(dateString + 'T00:00:00'); // Add time to avoid timezone issues
                const options = { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                };
                return date.toLocaleDateString('en-US', options);
            } catch (error) {
                return dateString; // Return original if parsing fails
            }
        }

        // Helper function to convert display format back to YYYY-MM-DD for input fields
        function convertDisplayToInputDate(displayDate) {
            if (!displayDate) return '';
            
            try {
                // If it's already in YYYY-MM-DD format, return as-is
                if (/^\d{4}-\d{2}-\d{2}$/.test(displayDate)) {
                    return displayDate;
                }
                
                // Try to parse the display format (e.g., "Mar 15, 2024")
                const date = new Date(displayDate);
                if (isNaN(date.getTime())) {
                    return displayDate; // Return original if parsing fails
                }
                
                // Convert to YYYY-MM-DD format
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            } catch (error) {
                return displayDate; // Return original if parsing fails
            }
        }

        function draw() {
            // Get canvas dimensions
            const rect = canvas.getBoundingClientRect();

            // Store drawable dimensions (in CSS pixels) with fallback
            const drawWidth = rect.width || 1200;
            const drawHeight = rect.height || 800;

            // Set canvas size (this resets the context)
            canvas.width = (rect.width || 1200) * window.devicePixelRatio;
            canvas.height = (rect.height || 800) * window.devicePixelRatio;

            // Apply scaling AFTER setting dimensions
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            // Clear canvas
            const isDark = document.documentElement.classList.contains('dark');
            ctx.fillStyle = isDark ? '#1f2937' : '#ffffff';
            ctx.fillRect(0, 0, drawWidth, drawHeight);

            // Draw light grid - ALWAYS draw this first
            ctx.save(); // Save context state
            ctx.strokeStyle = isDark ? '#1f2937' : '#f5f5f5'; // Lightest shade of grey
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3; // Very subtle
            const gridSize = 20;

            for (let x = 0; x < drawWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, drawHeight);
                ctx.stroke();
            }

            for (let y = 0; y < drawHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(drawWidth, y);
                ctx.stroke();
            }
            ctx.restore(); // Restore context state

            // Draw subtle generation guide lines
            ctx.save(); // Save context state
            ctx.globalAlpha = 0.6; // Make lines darker and more visible
            ctx.strokeStyle = isDark ? '#6b7280' : '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 6]); // Longer gaps, shorter dashes

            SNAP_LINES.forEach((lineY, index) => {
                ctx.beginPath();
                ctx.moveTo(0, lineY);
                ctx.lineTo(drawWidth, lineY);
                ctx.stroke();
            });

            ctx.setLineDash([]); // Reset line dash
            ctx.globalAlpha = 0.9; // Make text darker and more visible

            // Add subtle generation labels
            ctx.fillStyle = isDark ? '#6b7280' : '#9ca3af';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';

            SNAP_LINES.forEach((lineY, index) => {
                ctx.fillText(`Gen ${index + 1}`, 8, lineY - 8);
            });

            ctx.restore(); // Restore context state

            // Draw connections first (so they appear behind individuals)
            connections.forEach(connection => connection.draw(ctx));
            siblingConnections.forEach(siblingConnection => siblingConnection.draw(ctx));
            multiplesConnections.forEach(multiplesConnection => multiplesConnection.draw(ctx));
            parentSiblingConnections.forEach(parentSiblingConnection => parentSiblingConnection.draw(ctx));

            // Draw individuals
            individuals.forEach(individual => individual.draw(ctx));
            
            // Draw proband arrows (before text boxes so they appear under text)
            probandArrows.forEach(probandArrow => probandArrow.draw(ctx));
            
            // Draw separation symbols
            separationSymbols.forEach(separationSymbol => separationSymbol.draw(ctx));
            
            // Draw text boxes (after individuals, so they appear on top)
            textBoxes.forEach(textBox => textBox.draw(ctx));
            
            // Draw group selection bounding box for selected individuals
            if (selectedIndividuals.length > 1) {
                const padding = 20; // Padding around the group
                
                // Calculate bounding box of all selected individuals
                const minX = Math.min(...selectedIndividuals.map(ind => ind.x - SYMBOL_RADIUS)) - padding;
                const maxX = Math.max(...selectedIndividuals.map(ind => ind.x + SYMBOL_RADIUS)) + padding;
                const minY = Math.min(...selectedIndividuals.map(ind => ind.y - SYMBOL_RADIUS)) - padding;
                const maxY = Math.max(...selectedIndividuals.map(ind => ind.y + SYMBOL_RADIUS)) + padding;
                
                // Draw selection group box
                ctx.strokeStyle = '#5D5CDE';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.globalAlpha = 0.8;
                
                ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                
                // Add subtle background fill
                ctx.fillStyle = '#5D5CDE';
                ctx.globalAlpha = 0.05;
                ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
                
                // Reset styles
                ctx.setLineDash([]);
                ctx.globalAlpha = 1.0;
                
                // Add selection count badge
                ctx.fillStyle = '#5D5CDE';
                ctx.globalAlpha = 0.9;
                const badgeX = maxX - 25;
                const badgeY = minY + 5;
                const badgeWidth = 20;
                const badgeHeight = 16;
                
                // Draw badge background
                ctx.beginPath();
                ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, 3);
                ctx.fill();
                
                // Draw selection count
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(selectedIndividuals.length.toString(), badgeX + badgeWidth/2, badgeY + badgeHeight/2);
                
                ctx.globalAlpha = 1.0;
            }
            
            // Draw drag selection rectangle (while actively selecting)
            if (isGroupSelecting) {
                ctx.strokeStyle = '#5D5CDE';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.globalAlpha = 0.7;
                
                const left = Math.min(groupSelectStart.x, groupSelectEnd.x);
                const top = Math.min(groupSelectStart.y, groupSelectEnd.y);
                const width = Math.abs(groupSelectEnd.x - groupSelectStart.x);
                const height = Math.abs(groupSelectEnd.y - groupSelectStart.y);
                
                // Draw selection rectangle outline
                ctx.strokeRect(left, top, width, height);
                
                // Add subtle fill
                ctx.fillStyle = '#5D5CDE';
                ctx.globalAlpha = 0.1;
                ctx.fillRect(left, top, width, height);
                
                // Reset styles
                ctx.setLineDash([]);
                ctx.globalAlpha = 1.0;
            }
        }

        // Dynamic Pattern Management System
        let patternCounter = 0;
        let patternDefinitions = []; // Array to store {id, name, pattern}

        // Pattern types available
        const AVAILABLE_PATTERNS = [
            { type: 'solid', name: 'Solid Fill', symbol: '‚óè' },
            { type: 'diagonal1', name: 'Diagonal \\', symbol: '‚ó¢' },
            { type: 'horizontal', name: 'Horizontal Lines', symbol: '‚â°' },
            { type: 'vertical', name: 'Vertical Lines', symbol: '|||' },
            { type: 'dots', name: 'Dots', symbol: '‚à¥' },
            { type: 'crosshatch', name: 'Crosshatch', symbol: '‚úï' }
        ];

        // Pattern legend toggle functionality
        document.getElementById('togglePatternLegend').addEventListener('click', () => {
            const content = document.getElementById('patternLegendContent');
            const toggleText = document.getElementById('legendToggleText');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggleText.textContent = 'Collapse';
            } else {
                content.style.display = 'none';
                toggleText.textContent = 'Expand';
            }
        });

        // Add pattern button functionality
        document.getElementById('addPatternBtn').addEventListener('click', addNewPattern);

        function addNewPattern() {
            patternCounter++;
            const patternId = `pattern_${patternCounter}`;
            
            // Get available (unused) pattern types
            const availablePatternTypes = getAvailablePatternTypes();
            
            // Check if we have any available patterns left
            if (availablePatternTypes.length === 0) {
                showCustomAlert("All pattern types are already in use. Please remove an existing pattern or modify an existing one.");
                return;
            }
            
            // Default to first available pattern type
            const defaultPattern = availablePatternTypes[0];
            
            const patternEntry = {
                id: patternId,
                name: '',
                pattern: defaultPattern.type
            };
            
            patternDefinitions.push(patternEntry);
            
            renderPatternList();
            updateEmptyMessage();
        }

        function removePattern(patternId) {
            // Remove from definitions
            patternDefinitions = patternDefinitions.filter(p => p.id !== patternId);
            
            // Update any individuals using this pattern
            individuals.forEach(individual => {
                ['disorderTL', 'disorderTR', 'disorderBL', 'disorderBR'].forEach(quad => {
                    if (individual[quad] === getPatternName(patternId)) {
                        individual[quad] = '';
                        // Clear the corresponding pattern type
                        const patternQuad = quad.replace('disorder', 'pattern');
                        individual[patternQuad] = '';
                    }
                });
            });
            
            renderPatternList();
            updateEmptyMessage();
            updateDisorderDropdowns();
            draw();
        }

        function renderPatternList() {
            const patternList = document.getElementById('patternList');
            patternList.innerHTML = '';
            
            patternDefinitions.forEach(pattern => {
                const patternDiv = document.createElement('div');
                patternDiv.className = 'flex items-center space-x-3 p-2 bg-gray-50 dark:bg-gray-600 rounded border';
                
                // Get available pattern types for this pattern (including its current type)
                const availableForThis = getAvailablePatternTypesFor(pattern.id);
                
                patternDiv.innerHTML = `
                    <canvas id="canvas_${pattern.id}" width="24" height="24" class="border border-gray-300 dark:border-gray-500 rounded"></canvas>
                    <select id="type_${pattern.id}" class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                        ${availableForThis.map(p => 
                            `<option value="${p.type}" ${p.type === pattern.pattern ? 'selected' : ''}>${p.name}</option>`
                        ).join('')}
                    </select>
                    <input type="text" id="name_${pattern.id}" value="${pattern.name}" placeholder="e.g., Heart Disease" 
                           class="flex-1 px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700">
                    <button onclick="removePattern('${pattern.id}')" 
                            class="px-2 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600 transition-colors">
                        ‚úï
                    </button>
                `;
                
                patternList.appendChild(patternDiv);
                
                // Add event listeners
                const typeSelect = document.getElementById(`type_${pattern.id}`);
                const nameInput = document.getElementById(`name_${pattern.id}`);
                
                typeSelect.addEventListener('change', (e) => {
                    pattern.pattern = e.target.value;
                    drawPatternCanvas(pattern.id);
                    updateDisorderDropdowns();
                    // Re-render the pattern list to update dropdown options for all patterns
                    renderPatternList();
                });
                
                nameInput.addEventListener('input', (e) => {
                    pattern.name = e.target.value;
                    updateDisorderDropdowns();
                });
                
                nameInput.addEventListener('blur', (e) => {
                    pattern.name = e.target.value;
                    updateDisorderDropdowns();
                });

                // Add right-click context menu for pattern name input
                nameInput.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showPatternNameContextMenu(e, pattern.id);
                });

                // Add keyboard shortcut support for clearing pattern name
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Delete' && e.ctrlKey) {
                        e.preventDefault();
                        clearPatternName(pattern.id);
                    }
                });

                // Add visual feedback for text selection
                nameInput.addEventListener('focus', () => {
                    nameInput.classList.add('ring-2', 'ring-primary', 'ring-opacity-50');
                });

                nameInput.addEventListener('blur', () => {
                    nameInput.classList.remove('ring-2', 'ring-primary', 'ring-opacity-50');
                });

                // Add double-click to select all text
                nameInput.addEventListener('dblclick', () => {
                    nameInput.select();
                });
                
                // Draw the pattern canvas
                drawPatternCanvas(pattern.id);
            });
        }

        function drawPatternCanvas(patternId) {
            const pattern = patternDefinitions.find(p => p.id === patternId);
            if (!pattern) return;
            
            const canvas = document.getElementById(`canvas_${patternId}`);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            drawPatternExample(ctx, pattern.pattern, 24, 24);
        }

        function updateEmptyMessage() {
            const emptyMessage = document.getElementById('emptyPatternMessage');
            if (patternDefinitions.length === 0) {
                emptyMessage.style.display = 'block';
            } else {
                emptyMessage.style.display = 'none';
            }
        }

        function getPatternName(patternId) {
            const pattern = patternDefinitions.find(p => p.id === patternId);
            return pattern ? pattern.name : '';
        }

        // Dynamic legend system - map disease names to patterns
        function getLegendMapping() {
            const mapping = {};
            
            patternDefinitions.forEach(pattern => {
                if (pattern.name && pattern.name.trim()) {
                    mapping[pattern.name.trim()] = pattern.pattern;
                }
            });
            
            return mapping;
        }

        function updateDisorderDropdowns() {
            const dropdowns = ['disorderTL', 'disorderTR', 'disorderBL', 'disorderBR'];
            const availablePatterns = patternDefinitions.filter(p => p.name && p.name.trim());

            dropdowns.forEach(dropdownId => {
                const dropdown = document.getElementById(dropdownId);
                if (dropdown) {
                    const currentValue = dropdown.value;

                    // Clear existing options except "None"
                    dropdown.innerHTML = '<option value="">None</option>';

                    // Add pattern options
                    availablePatterns.forEach(pattern => {
                        const option = document.createElement('option');
                        option.value = pattern.name.trim();
                        option.textContent = pattern.name.trim();
                        dropdown.appendChild(option);
                    });

                    // Restore previous selection if still valid
                    const validNames = availablePatterns.map(p => p.name.trim());
                    if (validNames.includes(currentValue)) {
                        dropdown.value = currentValue;
                    }
                }
            });
        }

        function updateUnknownDisorderDropdowns() {
            const dropdowns = ['unknownDisorderTL', 'unknownDisorderTR', 'unknownDisorderBL', 'unknownDisorderBR'];
            const availablePatterns = patternDefinitions.filter(p => p.name && p.name.trim());

            dropdowns.forEach(dropdownId => {
                const dropdown = document.getElementById(dropdownId);
                if (dropdown) {
                    const currentValue = dropdown.value;

                    // Clear existing options except "None"
                    dropdown.innerHTML = '<option value="">None</option>';

                    // Add pattern options
                    availablePatterns.forEach(pattern => {
                        const option = document.createElement('option');
                        option.value = pattern.name.trim();
                        option.textContent = pattern.name.trim();
                        dropdown.appendChild(option);
                    });

                    // Restore previous selection if still valid
                    const validNames = availablePatterns.map(p => p.name.trim());
                    if (validNames.includes(currentValue)) {
                        dropdown.value = currentValue;
                    }
                }
            });
        }

        function getPatternForDisease(diseaseName) {
            const mapping = getLegendMapping();
            return mapping[diseaseName] || null;
        }

        // Get pattern types that are not currently in use
        function getAvailablePatternTypes() {
            const usedPatternTypes = patternDefinitions.map(p => p.pattern);
            return AVAILABLE_PATTERNS.filter(p => !usedPatternTypes.includes(p.type));
        }

        // Get pattern types available for a specific pattern (includes its current type + unused types)
        function getAvailablePatternTypesFor(patternId) {
            const currentPattern = patternDefinitions.find(p => p.id === patternId);
            const usedPatternTypes = patternDefinitions
                .filter(p => p.id !== patternId) // Exclude the current pattern from the used list
                .map(p => p.pattern);
            
            return AVAILABLE_PATTERNS.filter(p => 
                p.type === (currentPattern ? currentPattern.pattern : null) || // Include current pattern
                !usedPatternTypes.includes(p.type) // Include unused patterns
            );
        }

        // Initialize pattern system
        function initPatternSystem() {
            updateEmptyMessage();
            updateDisorderDropdowns();
        }

        // Initialize pattern examples
        function initPatternExamples() {
            const patterns = [
                { id: 'patternExample1', pattern: 'solid' },
                { id: 'patternExample2', pattern: 'diagonal1' },
                { id: 'patternExample3', pattern: 'horizontal' },
                { id: 'patternExample4', pattern: 'vertical' },
                { id: 'patternExample5', pattern: 'dots' },
                { id: 'patternExample6', pattern: 'crosshatch' }
            ];

            patterns.forEach(({ id, pattern }) => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    drawPatternExample(ctx, pattern, 24, 24);
                }
            });
        }

        function drawPatternExample(ctx, pattern, width, height) {
            ctx.clearRect(0, 0, width, height);
            
            const isDark = document.documentElement.classList.contains('dark');
            ctx.fillStyle = isDark ? '#ffffff' : '#000000';
            ctx.strokeStyle = isDark ? '#ffffff' : '#000000';
            ctx.lineWidth = 1;

            // Draw a circle as the example shape
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = width / 2 - 2;

            // Set clipping path to circle
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.clip();

            switch (pattern) {
                case 'solid':
                    ctx.fillRect(0, 0, width, height);
                    break;
                    
                case 'diagonal1': // \ lines
                    for (let i = -width; i <= width; i += 6) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i + height, height);
                        ctx.stroke();
                    }
                    break;

                case 'horizontal':
                    for (let y = 0; y <= height; y += 6) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                    break;

                case 'vertical':
                    for (let x = 0; x <= width; x += 6) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    break;
                    
                case 'dots':
                    for (let x = 2; x < width; x += 4) {
                        for (let y = 2; y < height; y += 4) {
                            ctx.beginPath();
                            ctx.arc(x, y, 0.5, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                    break;
                    
                case 'crosshatch':
                    // Draw both diagonal patterns
                    for (let i = -width; i <= width; i += 6) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i + height, height);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(i, height);
                        ctx.lineTo(i + height, 0);
                        ctx.stroke();
                    }
                    break;
            }

            ctx.restore();

            // Draw circle outline
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }

        // Initialize
        initSymbolPreviews();
        initPatternSystem();
        
        // Update previews on theme change
        const observer = new MutationObserver(() => {
            initSymbolPreviews();
            initPatternExamples();
        });
        observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
        
        // Initial draw
        setTimeout(() => {
            draw();
        }, 100);

        // PDF Download Functions
        function downloadPDF() {
            if (individuals.length === 0) {
                showCustomAlert("Please create a pedigree before downloading. Add some family members first.");
                return;
            }

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: 'a4'
                });

                // PAGE 1: Pedigree Chart with Legends
                // Add title
                pdf.setFontSize(16);
                pdf.setFont('helvetica', 'bold');
                pdf.text('Family Pedigree Chart', 20, 20);

                // Add creation date
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'normal');
                const currentDate = new Date().toLocaleDateString();
                pdf.text(`Generated on: ${currentDate}`, 20, 28);

                // Create a clean canvas for PDF export
                const exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');

                // Set canvas size to match the current canvas
                exportCanvas.width = canvas.width;
                exportCanvas.height = canvas.height;

                // Clear selections temporarily for clean export
                const originalSelections = [];
                individuals.forEach((ind, index) => {
                    originalSelections[index] = ind.selected;
                    ind.selected = false;
                });

                connections.forEach(conn => {
                    conn.selected = false;
                });
                siblingConnections.forEach(conn => {
                    conn.selected = false;
                });
                multiplesConnections.forEach(conn => {
                    conn.selected = false;
                });
                parentSiblingConnections.forEach(conn => {
                    conn.selected = false;
                });
                textBoxes.forEach(tb => {
                    tb.selected = false;
                });
                probandArrows.forEach(arrow => {
                    arrow.selected = false;
                });
                separationSymbols.forEach(symbol => {
                    symbol.selected = false;
                });

                // Draw the pedigree to the export canvas
                drawPedigreeToCanvas(exportCtx, exportCanvas.width, exportCanvas.height);

                // Convert canvas to image and add to PDF
                const canvasImageData = exportCanvas.toDataURL('image/png');

                // Calculate dimensions to fit on page while maintaining aspect ratio
                const maxWidth = 250; // mm - maximum width available
                const maxHeight = 150; // mm - maximum height available

                // Calculate aspect ratio of the canvas
                const canvasAspectRatio = exportCanvas.width / exportCanvas.height;
                const maxAspectRatio = maxWidth / maxHeight;

                let pdfWidth, pdfHeight;

                // Scale based on which dimension is the limiting factor
                if (canvasAspectRatio > maxAspectRatio) {
                    // Canvas is wider - limit by width
                    pdfWidth = maxWidth;
                    pdfHeight = maxWidth / canvasAspectRatio;
                } else {
                    // Canvas is taller - limit by height
                    pdfHeight = maxHeight;
                    pdfWidth = maxHeight * canvasAspectRatio;
                }

                pdf.addImage(canvasImageData, 'PNG', 20, 35, pdfWidth, pdfHeight);

                // Add disorder pattern legend in upper right corner AFTER the canvas (so it appears on top)
                const definedPatterns = patternDefinitions.filter(p => p.name && p.name.trim());
                if (definedPatterns.length > 0) {
                    addPatternLegendToPDF(pdf, 200, 20);
                }

                // Restore original selections
                individuals.forEach((ind, index) => {
                    ind.selected = originalSelections[index];
                });

                // PAGE 2: Individual Information Summary
                pdf.addPage();
                addIndividualSummaryPage(pdf);

                // Save the PDF
                const filename = `Family_Pedigree_${currentDate.replace(/\//g, '-')}.pdf`;
                pdf.save(filename);

                // Show success message
                showCustomAlert("PDF downloaded successfully! Check your downloads folder.");

            } catch (error) {
                console.error('PDF generation error:', error);
                showCustomAlert("Error generating PDF. Please try again.");
            }
        }

        function drawPedigreeToCanvas(ctx, width, height) {
            // Clear canvas with white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            
            // Draw light grid
            ctx.strokeStyle = '#f3f4f6';
            ctx.lineWidth = 1;
            const gridSize = 20;
            
            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw subtle generation guide lines for PDF
            ctx.globalAlpha = 0.3; // Slightly more visible for PDF
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 6]);
            
            SNAP_LINES.forEach((lineY, index) => {
                ctx.beginPath();
                ctx.moveTo(0, lineY);
                ctx.lineTo(width, lineY);
                ctx.stroke();
            });
            
            ctx.setLineDash([]);
            ctx.globalAlpha = 1.0;
            
            // Add subtle generation labels for PDF
            ctx.fillStyle = '#9ca3af';
            ctx.globalAlpha = 0.7;
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            
            SNAP_LINES.forEach((lineY, index) => {
                ctx.fillText(`Gen ${index + 1}`, 8, lineY - 8);
            });
            
            ctx.globalAlpha = 1.0;

            // Draw connections first (so they appear behind individuals)
            connections.forEach(connection => connection.draw(ctx));
            siblingConnections.forEach(siblingConnection => siblingConnection.draw(ctx));
            multiplesConnections.forEach(multiplesConnection => multiplesConnection.draw(ctx));
            parentSiblingConnections.forEach(parentSiblingConnection => parentSiblingConnection.draw(ctx));

            // Draw individuals
            individuals.forEach(individual => individual.draw(ctx));

            // Draw proband arrows (before text boxes so they appear under text)
            probandArrows.forEach(probandArrow => probandArrow.draw(ctx));

            // Draw separation symbols
            separationSymbols.forEach(separationSymbol => separationSymbol.draw(ctx));

            // Draw text boxes (after individuals, so they appear on top)
            textBoxes.forEach(textBox => textBox.draw(ctx));
        }

        function addSymbolLegendToPDF(pdf, x, y) {
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'bold');
            pdf.text('Symbol Legend:', x, y);
            
            pdf.setFontSize(9);
            pdf.setFont('helvetica', 'normal');
            
            const legendItems = [
                { text: '‚óª Male (Square)', yOffset: 8 },
                { text: '‚óØ Female (Circle)', yOffset: 12 },
                { text: '‚óá Unknown (Diamond)', yOffset: 16 },
                { text: '‚ñ≥ Miscarriage (Triangle)', yOffset: 20 },
                { text: '‚îÄ Marriage/Partnership (Draggable)', yOffset: 24 },
                { text: '‚ïê Consanguineous Marriage (Draggable Double Line)', yOffset: 28 },
                { text: '‚óª/ Deceased (Slash)', yOffset: 32 }
            ];
            
            legendItems.forEach(item => {
                pdf.text(item.text, x, y + item.yOffset);
            });
            
            return y + 35;
        }

        function addPatternLegendToPDF(pdf, x, y) {
            // Get defined patterns from the dynamic pattern system
            const definedPatterns = patternDefinitions.filter(p => p.name && p.name.trim());

            if (definedPatterns.length === 0) {
                return y; // No patterns defined
            }

            // PDF page dimensions (A4 landscape)
            const pageWidth = 297; // mm
            const rightMargin = 20; // mm from right edge
            const maxTextWidth = pageWidth - x - rightMargin - 10; // Available width for text

            // Add title with background box for better visibility
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'bold');
            pdf.text('Disorder Legend', x, y);

            // Create canvases for pattern thumbnails
            let currentY = y + 7;
            const thumbnailSize = 8; // Larger size for better visibility
            const lineHeight = 10; // Spacing between items
            const textX = x + thumbnailSize + 3; // X position for text

            definedPatterns.forEach((pattern, index) => {
                // Create a temporary canvas for the pattern thumbnail
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 32;
                tempCanvas.height = 32;
                const tempCtx = tempCanvas.getContext('2d');

                // Clear background to white
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, 32, 32);

                // Draw the pattern example as a circle (like it appears on individuals)
                tempCtx.save();
                tempCtx.beginPath();
                tempCtx.arc(16, 16, 14, 0, 2 * Math.PI);
                tempCtx.clip();

                // Draw the pattern
                drawPatternExample(tempCtx, pattern.pattern, 32, 32);

                tempCtx.restore();

                // Draw circle outline
                tempCtx.strokeStyle = '#000000';
                tempCtx.lineWidth = 2;
                tempCtx.beginPath();
                tempCtx.arc(16, 16, 14, 0, 2 * Math.PI);
                tempCtx.stroke();

                // Convert pattern canvas to image and add to PDF
                const patternImageData = tempCanvas.toDataURL('image/png');
                pdf.addImage(patternImageData, 'PNG', x, currentY - 4, thumbnailSize, thumbnailSize);

                // Handle text with compact formatting
                pdf.setFontSize(9);
                pdf.setFont('helvetica', 'normal');

                const patternName = pattern.name.trim();

                // Keep text on single line but truncate if too long
                let displayText = patternName;
                if (pdf.getTextWidth(displayText) > maxTextWidth) {
                    while (pdf.getTextWidth(displayText + '...') > maxTextWidth && displayText.length > 3) {
                        displayText = displayText.slice(0, -1);
                    }
                    displayText += '...';
                }

                pdf.text(displayText, textX, currentY);

                // Move to next item position
                currentY += lineHeight;
            });

            return currentY + 5;
        }



        function addIndividualDetailsToPDF(pdf) {
            // Filter individuals with meaningful data
            const individualsWithData = individuals.filter(ind => 
                ind.name || ind.birth || ind.notes || ind.fillChar || 
                ind.patternTL || ind.patternTR || ind.patternBL || ind.patternBR
            );
            
            if (individualsWithData.length === 0) {
                return; // No individuals with data to show
            }
            
            // Add new page for individual details
            pdf.addPage();
            
            pdf.setFontSize(16);
            pdf.setFont('helvetica', 'bold');
            pdf.text('Individual Information', 20, 20);
            
            let currentY = 35;
            const pageHeight = 200; // Usable page height
            const itemHeight = 25; // Height per individual entry
            
            individualsWithData.forEach((individual, index) => {
                // Check if we need a new page
                if (currentY + itemHeight > pageHeight) {
                    pdf.addPage();
                    currentY = 20;
                }
                
                // Individual header
                pdf.setFontSize(12);
                pdf.setFont('helvetica', 'bold');
                const individualTitle = individual.name || `Individual ${index + 1}`;
                pdf.text(`${individualTitle} (${getTypeDisplayName(individual.type)})`, 20, currentY);
                
                // Individual details
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'normal');
                currentY += 5;
                
                const details = [];
                if (individual.name) details.push(`Name: ${individual.name}`);
                if (individual.birth) details.push(`Birth Year: ${individual.birth}`);
                if (individual.fillChar) details.push(`Fill Character: ${individual.fillChar}`);
                if (individual.deceased) details.push(`Status: Deceased`);
                
                // Add pattern information
                const patterns = getIndividualPatterns(individual);
                if (patterns.length > 0) {
                    details.push(`Patterns: ${patterns.join(', ')}`);
                }
                
                if (individual.notes) details.push(`Notes: ${individual.notes}`);
                
                details.forEach(detail => {
                    pdf.text(detail, 25, currentY);
                    currentY += 4;
                });
                
                currentY += 5; // Space between individuals
            });
        }

        function getTypeDisplayName(type) {
            const typeNames = {
                'male': 'Male',
                'female': 'Female',
                'unknown': 'Unknown',
                'miscarriage': 'Miscarriage',
                'pregnancy': 'Pregnancy'
            };
            return typeNames[type] || type;
        }

        function getIndividualPatterns(individual) {
            const patterns = [];

            // Show disorder names instead of pattern types
            if (individual.disorderTL) patterns.push(`TL: ${individual.disorderTL}`);
            if (individual.disorderTR) patterns.push(`TR: ${individual.disorderTR}`);
            if (individual.disorderBL) patterns.push(`BL: ${individual.disorderBL}`);
            if (individual.disorderBR) patterns.push(`BR: ${individual.disorderBR}`);

            return patterns;
        }

        function addIndividualSummaryPage(pdf) {
            // Page 2: Individual Information Summary
            pdf.setFontSize(16);
            pdf.setFont('helvetica', 'bold');
            pdf.text('Individual Information Summary', 20, 20);

            let currentY = 35;
            const pageHeight = 190; // Usable page height in landscape A4
            const leftMargin = 20;
            const rightMargin = 277; // A4 landscape width (297mm) - 20mm margin
            const columnWidth = (rightMargin - leftMargin) / 2 - 5; // Two columns with 5mm gap

            // Filter individuals with meaningful data
            const individualsWithData = individuals.filter(ind =>
                ind.name || ind.birth || ind.notes || ind.fillChar ||
                ind.patternTL || ind.patternTR || ind.patternBL || ind.patternBR ||
                ind.deceased || ind.sexAtBirth || ind.genderIdentity || ind.comments ||
                ind.lmp || ind.edc ||
                ind.maternalHypertension || ind.maternalPreeclampsia ||
                ind.maternalGestationalDiabetes || ind.maternalIDDM ||
                ind.maternalTeratogenicExposure || ind.maternalPlacentalBleeding ||
                ind.maternalOther || ind.fetalIUGR || ind.fetalPosNIPT ||
                ind.fetalOligoPolyHydramnios || ind.fetal3VesselCord ||
                ind.fetalSoftSignsUS || ind.fetalOther
            );

            if (individualsWithData.length === 0) {
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'italic');
                pdf.text('No individual information has been recorded.', leftMargin, currentY);
                return;
            }

            individualsWithData.forEach((individual, index) => {
                // Calculate space needed for this individual
                const details = getIndividualDetailsArray(individual);
                const neededHeight = 10 + (details.length * 4) + 8; // Header + details + spacing

                // Check if we need a new page
                if (currentY + neededHeight > pageHeight) {
                    pdf.addPage();
                    currentY = 20;
                }

                // Individual header
                pdf.setFontSize(11);
                pdf.setFont('helvetica', 'bold');
                const individualTitle = individual.name || `Individual ${index + 1}`;
                const typeDisplay = getTypeDisplayName(individual.type);
                pdf.text(`${individualTitle} (${typeDisplay})`, leftMargin, currentY);

                currentY += 6;

                // Individual details
                pdf.setFontSize(9);
                pdf.setFont('helvetica', 'normal');

                details.forEach(detail => {
                    // Split long text to fit in column width
                    const lines = pdf.splitTextToSize(detail, columnWidth * 2);
                    lines.forEach(line => {
                        if (currentY + 4 > pageHeight) {
                            pdf.addPage();
                            currentY = 20;
                        }
                        pdf.text(line, leftMargin + 5, currentY);
                        currentY += 4;
                    });
                });

                currentY += 5; // Space between individuals
            });
        }

        function getIndividualDetailsArray(individual) {
            const details = [];

            // Basic information
            if (individual.name) details.push(`‚Ä¢ Name: ${individual.name}`);
            if (individual.birth) details.push(`‚Ä¢ Birth Year: ${individual.birth}`);
            if (individual.deceased) details.push(`‚Ä¢ Status: Deceased`);

            // Disorders/Patterns
            const patterns = getIndividualPatterns(individual);
            if (patterns.length > 0) {
                details.push(`‚Ä¢ Disorders: ${patterns.join(', ')}`);
            }

            // Notes
            if (individual.notes) details.push(`‚Ä¢ Notes: ${individual.notes}`);

            // Unknown individual specific fields
            if (individual.sexAtBirth) details.push(`‚Ä¢ Sex at Birth: ${individual.sexAtBirth}`);
            if (individual.genderIdentity) details.push(`‚Ä¢ Gender Identity: ${individual.genderIdentity}`);
            if (individual.comments) details.push(`‚Ä¢ Comments: ${individual.comments}`);

            // Pregnancy-specific fields
            if (individual.type === 'pregnancy') {
                if (individual.lmp) details.push(`‚Ä¢ Last Menstrual Period: ${individual.lmp}`);
                if (individual.edc) details.push(`‚Ä¢ Expected Date of Confinement: ${individual.edc}`);

                // Maternal complications
                const maternalComplications = [];
                if (individual.maternalHypertension) maternalComplications.push('Hypertension');
                if (individual.maternalPreeclampsia) maternalComplications.push('Preeclampsia');
                if (individual.maternalGestationalDiabetes) maternalComplications.push('Gestational Diabetes');
                if (individual.maternalIDDM) maternalComplications.push('IDDM');
                if (individual.maternalTeratogenicExposure) maternalComplications.push('Teratogenic Exposure');
                if (individual.maternalPlacentalBleeding) maternalComplications.push('Placental Bleeding');
                if (individual.maternalOther) maternalComplications.push('Other');

                if (maternalComplications.length > 0) {
                    details.push(`‚Ä¢ Maternal Complications: ${maternalComplications.join(', ')}`);
                }

                // Fetal complications
                const fetalComplications = [];
                if (individual.fetalIUGR) fetalComplications.push('IUGR');
                if (individual.fetalPosNIPT) fetalComplications.push('Positive NIPT');
                if (individual.fetalOligoPolyHydramnios) fetalComplications.push('Oligo/Polyhydramnios');
                if (individual.fetal3VesselCord) fetalComplications.push('3 Vessel Cord');
                if (individual.fetalSoftSignsUS) fetalComplications.push('Soft Signs on US');
                if (individual.fetalOther) fetalComplications.push('Other');

                if (fetalComplications.length > 0) {
                    details.push(`‚Ä¢ Fetal Complications: ${fetalComplications.join(', ')}`);
                }
            }

            return details;
        }



        // Group dragging helper functions
        function getGroupBounds() {
            if (selectedIndividuals.length === 0) return null;
            
            const padding = 20; // Padding around the group
            
            const minX = Math.min(...selectedIndividuals.map(ind => ind.x - SYMBOL_RADIUS)) - padding;
            const maxX = Math.max(...selectedIndividuals.map(ind => ind.x + SYMBOL_RADIUS)) + padding;
            const minY = Math.min(...selectedIndividuals.map(ind => ind.y - SYMBOL_RADIUS)) - padding;
            const maxY = Math.max(...selectedIndividuals.map(ind => ind.y + SYMBOL_RADIUS)) + padding;
            
            return {
                left: minX,
                right: maxX,
                top: minY,
                bottom: maxY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        
        function isPointInGroupBounds(x, y, bounds) {
            if (!bounds) return false;
            
            return x >= bounds.left && x <= bounds.right && 
                   y >= bounds.top && y <= bounds.bottom;
        }

        // Keyboard event listener for delete/backspace keys and copy/paste
        document.addEventListener('keydown', function(event) {
            // Handle ESC key to close any open modal
            if (event.key === 'Escape') {
                // Check for open modals and close them
                const modals = [
                    { element: document.getElementById('textBoxModal'), closeFunction: closeTextBoxModal },
                    { element: document.getElementById('pregnancyModal'), closeFunction: closePregnancyModal },
                    { element: document.getElementById('miscarriageModal'), closeFunction: closeMiscarriageModal },
                    { element: document.getElementById('tabModal'), closeFunction: closeTabModal },
                    { element: document.getElementById('feedbackModal'), closeFunction: closeFeedbackModal },
                    { element: document.getElementById('infoModal'), closeFunction: closeInfoModal },
                    { element: document.getElementById('unknownInfoModal'), closeFunction: closeUnknownModal }
                ];
                
                // Close any open modal
                modals.forEach(modal => {
                    if (modal.element && !modal.element.classList.contains('hidden')) {
                        event.preventDefault();
                        modal.closeFunction();
                        return;
                    }
                });
                
                // Also close any context menus
                const contextMenu = document.getElementById('contextMenu');
                const patternContextMenu = document.getElementById('patternNameContextMenu');
                if (contextMenu) {
                    event.preventDefault();
                    contextMenu.remove();
                    return;
                }
                if (patternContextMenu) {
                    event.preventDefault();
                    patternContextMenu.remove();
                    return;
                }
                
                return;
            }
            
            // Check if we're currently in an input field, textarea, or other editable element
            const activeElement = document.activeElement;
            const isInInputField = activeElement && (
                activeElement.tagName === 'INPUT' || 
                activeElement.tagName === 'TEXTAREA' || 
                activeElement.contentEditable === 'true' ||
                activeElement.isContentEditable
            );
            
            // If we're in an input field, let the browser handle most keys normally
            if (isInInputField) {
                // Allow Ctrl+A (select all) in input fields
                if (event.ctrlKey && event.key.toLowerCase() === 'a') {
                    return;
                }
                // Don't interfere with normal text editing for other keys
                return;
            }
            
            const isCtrlCmd = event.ctrlKey || event.metaKey;
            
            // Copy functionality (Ctrl+C or Cmd+C)
            if (isCtrlCmd && event.key.toLowerCase() === 'c') {
                event.preventDefault();
                copySelected();
                return;
            }
            
            // Paste functionality (Ctrl+V or Cmd+V)
            if (isCtrlCmd && event.key.toLowerCase() === 'v') {
                event.preventDefault();
                pasteClipboard();
                return;
            }
            
            // Select All functionality (Ctrl+A or Cmd+A)
            if (isCtrlCmd && event.key.toLowerCase() === 'a') {
                event.preventDefault();
                selectAll();
                return;
            }
            
            // Undo functionality (Ctrl+Z or Cmd+Z)
            if (isCtrlCmd && event.key.toLowerCase() === 'z' && !event.shiftKey) {
                event.preventDefault();
                undoLastAction();
                return;
            }
            
            // Check if Delete or Backspace key is pressed (only when NOT in input fields)
            if (event.key === 'Delete' || event.key === 'Backspace') {
                // Prevent default browser behavior (like going back in history for Backspace)
                event.preventDefault();

                // Check if any items are selected
                const hasSelectedIndividuals = selectedIndividuals.length > 0;
                const hasSelectedConnections = connections.some(conn => conn.selected);
                const hasSelectedSiblingConnections = siblingConnections.some(conn => conn.selected);
                const hasSelectedMultiplesConnections = multiplesConnections.some(conn => conn.selected);
                const hasSelectedParentSiblingConnections = parentSiblingConnections.some(conn => conn.selected);
                const hasSelectedTextBoxes = textBoxes.some(tb => tb.selected);
                const hasSelectedProbandArrows = probandArrows.some(arrow => arrow.selected);
                const hasSelectedSeparationSymbols = separationSymbols.some(symbol => symbol.selected);

                if (hasSelectedIndividuals || hasSelectedConnections || hasSelectedSiblingConnections ||
                    hasSelectedMultiplesConnections || hasSelectedParentSiblingConnections || hasSelectedTextBoxes || hasSelectedProbandArrows ||
                    hasSelectedSeparationSymbols) {
                    // Call the existing delete function
                    deleteSelected();
                }
            }
        });

        // Jump to Instructions function
        function jumpToInstructions() {
            const instructionsSection = document.getElementById('instructionsSection');
            if (instructionsSection) {
                instructionsSection.scrollIntoView({ 
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        }

        // Open ICD-11 Code Browser function
        function openICD11Browser() {
            const icd11Url = 'https://icd.who.int/browse/2025-01/mms/en';
            window.open(icd11Url, '_blank');
        }

        // Pattern name context menu and clearing functions
        function showPatternNameContextMenu(event, patternId) {
            // Remove any existing context menu
            const existingMenu = document.getElementById('patternNameContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const contextMenu = document.createElement('div');
            contextMenu.id = 'patternNameContextMenu';
            contextMenu.className = 'fixed bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg z-50 py-2 min-w-[120px]';
            
            // Context menu options
            const menuItems = [
                {
                    label: 'Clear Text',
                    icon: 'üóëÔ∏è',
                    action: () => clearPatternName(patternId),
                    className: 'text-red-600 dark:text-red-400'
                }
            ];
            
            menuItems.forEach((menuItem) => {
                const menuElement = document.createElement('div');
                menuElement.className = `px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer flex items-center space-x-2 text-sm ${menuItem.className}`;
                menuElement.innerHTML = `
                    <span>${menuItem.icon}</span>
                    <span>${menuItem.label}</span>
                `;
                
                menuElement.addEventListener('click', () => {
                    menuItem.action();
                    contextMenu.remove();
                });
                
                contextMenu.appendChild(menuElement);
            });
            
            // Position the context menu
            document.body.appendChild(contextMenu);
            
            // Calculate position relative to viewport
            const viewportX = event.clientX;
            const viewportY = event.clientY;
            
            // Get menu dimensions
            const menuRect = contextMenu.getBoundingClientRect();
            
            // Adjust position if menu would go off screen
            let finalX = viewportX;
            let finalY = viewportY;
            
            if (finalX + menuRect.width > window.innerWidth) {
                finalX = window.innerWidth - menuRect.width - 10;
            }
            
            if (finalY + menuRect.height > window.innerHeight) {
                finalY = window.innerHeight - menuRect.height - 10;
            }
            
            contextMenu.style.left = `${finalX}px`;
            contextMenu.style.top = `${finalY}px`;
            
            // Close menu when clicking elsewhere
            const closeMenu = (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                    document.removeEventListener('contextmenu', closeMenu);
                }
            };
            
            // Add slight delay to prevent immediate closure
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
                document.addEventListener('contextmenu', closeMenu);
            }, 100);
        }

        function clearPatternName(patternId) {
            const pattern = patternDefinitions.find(p => p.id === patternId);
            if (pattern) {
                // Clear the pattern name
                pattern.name = '';
                
                // Update the input field
                const nameInput = document.getElementById(`name_${patternId}`);
                if (nameInput) {
                    nameInput.value = '';
                }
                
                // Update disorder dropdowns to reflect the change
                updateDisorderDropdowns();
                
                // Update any individuals that were using this pattern
                individuals.forEach(individual => {
                    ['disorderTL', 'disorderTR', 'disorderBL', 'disorderBR'].forEach(quad => {
                        if (individual[quad] === getPatternName(patternId)) {
                            individual[quad] = '';
                            // Clear the corresponding pattern type
                            const patternQuad = quad.replace('disorder', 'pattern');
                            individual[patternQuad] = '';
                        }
                    });
                });
                
                // Redraw the canvas to reflect any changes
                draw();
            }
        }

        // Copy and Paste Functions
        function copySelected() {
            // Check for separation symbols too
            const hasSelection = selectedIndividuals.length > 0 || 
                                textBoxes.some(tb => tb.selected) ||
                                probandArrows.some(arrow => arrow.selected) ||
                                separationSymbols.some(symbol => symbol.selected);
            
            if (!hasSelection) {
                showBriefMessage('No items selected to copy');
                return;
            }
            
            // Clear previous clipboard
            clipboard = {
                individuals: [],
                connections: [],
                textBoxes: [],
                probandArrows: [],
                separationSymbols: []
            };
            
            // Copy selected individuals
            selectedIndividuals.forEach(individual => {
                clipboard.individuals.push({
                    ...individual,
                    originalId: individual.id // Keep reference to original for connection mapping
                });
            });
            
            // Note: Connection system has been removed from this application
            
            // Copy selected text boxes
            textBoxes.forEach(textBox => {
                if (textBox.selected) {
                    clipboard.textBoxes.push({ ...textBox });
                }
            });
            
            // Copy selected proband arrows
            probandArrows.forEach(probandArrow => {
                if (probandArrow.selected) {
                    clipboard.probandArrows = clipboard.probandArrows || [];
                    clipboard.probandArrows.push({ ...probandArrow });
                }
            });
            
            // Copy selected separation symbols
            separationSymbols.forEach(separationSymbol => {
                if (separationSymbol.selected) {
                    clipboard.separationSymbols = clipboard.separationSymbols || [];
                    clipboard.separationSymbols.push({ ...separationSymbol });
                }
            });
            
            // Update paste button state
            updatePasteButton();
            
            const itemCount = clipboard.individuals.length + clipboard.connections.length + clipboard.textBoxes.length + 
                            (clipboard.probandArrows ? clipboard.probandArrows.length : 0) +
                            (clipboard.separationSymbols ? clipboard.separationSymbols.length : 0);
            showBriefMessage(`Copied ${itemCount} item${itemCount !== 1 ? 's' : ''} to clipboard`);
        }
        
        function pasteClipboard() {
            if (clipboard.individuals.length === 0 && clipboard.connections.length === 0 && clipboard.textBoxes.length === 0 && (!clipboard.probandArrows || clipboard.probandArrows.length === 0)) {
                showBriefMessage('Nothing to paste - clipboard is empty');
                return;
            }
            
            // Save state before pasting
            saveState();
            
            // Calculate center of clipboard content
            let centerX = 0, centerY = 0;
            const totalItems = clipboard.individuals.length + clipboard.textBoxes.length;
            
            if (clipboard.individuals.length > 0) {
                centerX += clipboard.individuals.reduce((sum, ind) => sum + ind.x, 0);
                centerY += clipboard.individuals.reduce((sum, ind) => sum + ind.y, 0);
            }
            
            if (clipboard.textBoxes.length > 0) {
                centerX += clipboard.textBoxes.reduce((sum, tb) => sum + tb.x, 0);
                centerY += clipboard.textBoxes.reduce((sum, tb) => sum + tb.y, 0);
            }
            
            if (totalItems > 0) {
                centerX /= totalItems;
                centerY /= totalItems;
            }
            
            // Calculate paste offset (paste to center of canvas)
            const canvasRect = canvas.getBoundingClientRect();
            const canvasCenterX = canvas.width / (2 * window.devicePixelRatio);
            const canvasCenterY = canvas.height / (2 * window.devicePixelRatio);
            
            const offsetX = canvasCenterX - centerX;
            const offsetY = canvasCenterY - centerY;
            
            // Clear current selections
            individuals.forEach(ind => ind.selected = false);
            connections.forEach(conn => conn.selected = false);
            textBoxes.forEach(tb => tb.selected = false);
            selectedIndividuals = [];
            
            // Create mapping from original IDs to new IDs for individuals
            const idMapping = {};
            
            // Paste individuals
            clipboard.individuals.forEach(clipboardIndividual => {
                const newId = Date.now() + Math.random();
                idMapping[clipboardIndividual.originalId] = newId;
                
                const newIndividual = new Individual(
                    clipboardIndividual.x + offsetX,
                    snapToLine(clipboardIndividual.y + offsetY),
                    clipboardIndividual.type,
                    newId
                );
                
                // Copy all properties except position and IDs
                Object.assign(newIndividual, {
                    name: clipboardIndividual.name,
                    birth: clipboardIndividual.birth,
                    notes: clipboardIndividual.notes,
                    fillChar: clipboardIndividual.fillChar,
                    showName: clipboardIndividual.showName,
                    showBirth: clipboardIndividual.showBirth,
                    showNotes: clipboardIndividual.showNotes,
                    patternTL: clipboardIndividual.patternTL,
                    patternTR: clipboardIndividual.patternTR,
                    patternBL: clipboardIndividual.patternBL,
                    patternBR: clipboardIndividual.patternBR,
                    disorderTL: clipboardIndividual.disorderTL,
                    disorderTR: clipboardIndividual.disorderTR,
                    disorderBL: clipboardIndividual.disorderBL,
                    disorderBR: clipboardIndividual.disorderBR,
                    deceased: clipboardIndividual.deceased,
                    selected: true // Select the pasted item
                });
                
                individuals.push(newIndividual);
                selectedIndividuals.push(newIndividual);
            });
            
            // Paste connections (only if both endpoints were pasted)
            clipboard.connections.forEach(clipboardConnection => {
                const newFromId = idMapping[clipboardConnection.fromOriginalId];
                const newToId = idMapping[clipboardConnection.toOriginalId];
                
                if (newFromId && newToId) {
                    const fromIndividual = individuals.find(ind => ind.id === newFromId);
                    const toIndividual = individuals.find(ind => ind.id === newToId);
                    
                    if (fromIndividual && toIndividual) {
                        const newConnection = new Connection(fromIndividual, toIndividual, clipboardConnection.type);
                        newConnection.selected = true; // Select the pasted connection
                        connections.push(newConnection);
                    }
                }
            });
            
            // Paste text boxes
            clipboard.textBoxes.forEach(clipboardTextBox => {
                const newId = Date.now() + Math.random();
                const newTextBox = new TextBox(
                    clipboardTextBox.x + offsetX,
                    clipboardTextBox.y + offsetY,
                    clipboardTextBox.text,
                    newId
                );
                
                // Copy all properties
                Object.assign(newTextBox, {
                    fontSize: clipboardTextBox.fontSize,
                    fontFamily: clipboardTextBox.fontFamily,
                    width: clipboardTextBox.width,
                    height: clipboardTextBox.height,
                    padding: clipboardTextBox.padding,
                    maxWidth: clipboardTextBox.maxWidth,
                    minWidth: clipboardTextBox.minWidth,
                    minHeight: clipboardTextBox.minHeight,
                    handleSize: clipboardTextBox.handleSize,
                    selected: true // Select the pasted text box
                });
                
                textBoxes.push(newTextBox);
            });
            
            // Paste proband arrows
            if (clipboard.probandArrows) {
                clipboard.probandArrows.forEach(clipboardArrow => {
                    const newId = Date.now() + Math.random();
                    const newArrow = new ProbanadArrow(
                        clipboardArrow.x + offsetX,
                        clipboardArrow.y + offsetY,
                        newId
                    );
                    
                    // Copy all properties
                    Object.assign(newArrow, {
                        size: clipboardArrow.size,
                        angle: clipboardArrow.angle,
                        selected: true // Select the pasted arrow
                    });
                    
                    probandArrows.push(newArrow);
                });
            }
            
            // Redraw canvas
            draw();
            
            const itemCount = clipboard.individuals.length + clipboard.connections.length + clipboard.textBoxes.length + (clipboard.probandArrows ? clipboard.probandArrows.length : 0);
            showBriefMessage(`Pasted ${itemCount} item${itemCount !== 1 ? 's' : ''} from clipboard`);
        }
        
        function selectAll() {
            // Clear current selections
            individuals.forEach(ind => ind.selected = false);
            connections.forEach(conn => conn.selected = false);
            textBoxes.forEach(tb => tb.selected = false);
            selectedIndividuals = [];
            
            // Select all individuals
            individuals.forEach(individual => {
                individual.selected = true;
                selectedIndividuals.push(individual);
            });
            
            // Note: Connection system has been removed from this application
            
            // Select all text boxes
            textBoxes.forEach(textBox => {
                textBox.selected = true;
            });
            
            // Redraw canvas
            draw();
            
            const totalCount = individuals.length + textBoxes.length;
            if (totalCount > 0) {
                showBriefMessage(`Selected all ${totalCount} items`);
            } else {
                showBriefMessage('No items to select');
            }
        }
        
        function updatePasteButton() {
            const pasteBtn = document.getElementById('btn-paste');
            const hasClipboardContent = clipboard.individuals.length > 0 || 
                                      clipboard.connections.length > 0 || 
                                      clipboard.textBoxes.length > 0;
            
            if (hasClipboardContent) {
                pasteBtn.disabled = false;
                pasteBtn.title = `Paste ${clipboard.individuals.length + clipboard.connections.length + clipboard.textBoxes.length} items from clipboard`;
            } else {
                pasteBtn.disabled = true;
                pasteBtn.title = 'Nothing to paste - clipboard is empty';
            }
        }

        // Smart Family Connection Functions
        function updateFamilyConnectionButton() {
            const familyBtn = document.getElementById('btn-connect-family');
            const familyData = analyzeFamilySelection();
            
            if (familyData.isValidFamily) {
                familyBtn.disabled = false;
                familyBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                familyBtn.classList.add('hover:bg-emerald-700');
                familyBtn.title = `Connect ${familyData.parents.length} parents to ${familyData.children.length} children as a family`;
            } else {
                familyBtn.disabled = true;
                familyBtn.classList.add('opacity-50', 'cursor-not-allowed');
                familyBtn.classList.remove('hover:bg-emerald-700');
                familyBtn.title = 'Select parents on one generation and children on a lower generation to connect as family';
            }
        }

        function analyzeFamilySelection() {
            if (selectedIndividuals.length < 2) {
                return { isValidFamily: false };
            }

            // Group by generations (Y positions)
            const generations = {};
            selectedIndividuals.forEach(individual => {
                const generation = findClosestSnapLine(individual.y);
                if (!generations[generation]) {
                    generations[generation] = [];
                }
                generations[generation].push(individual);
            });

            const generationKeys = Object.keys(generations).map(Number).sort((a, b) => a - b);

            if (generationKeys.length !== 2) {
                return { isValidFamily: false }; // Must be exactly 2 generations
            }

            const higherGeneration = generations[generationKeys[0]]; // Parents
            const lowerGeneration = generations[generationKeys[1]];  // Children

            // Check for valid parent combination
            const parentMales = higherGeneration.filter(ind => ind.type === 'male');
            const parentFemales = higherGeneration.filter(ind => ind.type === 'female');
            const parentOthers = higherGeneration.filter(ind => ind.type !== 'male' && ind.type !== 'female');

            let validParents = false;

            if (higherGeneration.length === 2) {
                // Exactly 2 parents - ideal case
                if ((parentMales.length === 1 && parentFemales.length === 1) || // Standard male-female pair
                    (parentMales.length === 2) || // Same-sex male couple
                    (parentFemales.length === 2) || // Same-sex female couple
                    (parentOthers.length > 0)) { // Include unknown/other types
                    validParents = true;
                }
            } else if (higherGeneration.length === 1) {
                // Single parent - also valid for family creation
                validParents = true;
            }

            // Must have at least 1 child
            const validChildren = lowerGeneration.length >= 1;
            
            return {
                isValidFamily: validParents && validChildren,
                parents: higherGeneration,
                children: lowerGeneration,
                parentMales: parentMales,
                parentFemales: parentFemales
            };
        }

        function findClosestSnapLine(y) {
            let closest = SNAP_LINES[0];
            let minDistance = Math.abs(y - closest);
            
            for (let line of SNAP_LINES) {
                const distance = Math.abs(y - line);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = line;
                }
            }
            
            return closest;
        }

        function connectSelectedAsFamily() {
            const familyData = analyzeFamilySelection();

            if (!familyData.isValidFamily) {
                showCustomAlert("Invalid family selection. Please select parents on one generation and children on a lower generation.");
                return;
            }

            // Save state before making changes
            saveState();

            const { parents, children } = familyData;

            // Determine the parent source (marriage or single parent)
            let parentSource = null;

            if (parents.length === 2) {
                // Two parents - create or find marriage connection
                const parent1 = parents[0];
                const parent2 = parents[1];

                // Check if marriage connection already exists
                parentSource = connections.find(conn =>
                    conn.type === 'marriage' &&
                    ((conn.from === parent1 && conn.to === parent2) ||
                     (conn.from === parent2 && conn.to === parent1))
                );

                if (!parentSource) {
                    parentSource = new Connection(parent1, parent2, 'marriage');
                    connections.push(parentSource);
                }
            } else if (parents.length === 1) {
                // Single parent - use the Individual directly
                parentSource = parents[0];
            }

            // Determine the child target (multiples group, sibling group, or single child)
            let childTarget = null;

            if (children.length >= 2) {
                // IMPORTANT: Expand children to include ALL members of any multiples groups
                // When connecting as family, if any child is part of a multiples group,
                // ALL members of that group must be included as siblings
                const allChildren = [];
                const processedMultiples = new Set();

                children.forEach(child => {
                    const multiplesGroup = multiplesConnections.find(multConn =>
                        multConn.multiples.includes(child)
                    );

                    if (multiplesGroup && !processedMultiples.has(multiplesGroup)) {
                        // Add ALL members of the multiples group
                        processedMultiples.add(multiplesGroup);
                        multiplesGroup.multiples.forEach(multiple => {
                            if (!allChildren.includes(multiple)) {
                                allChildren.push(multiple);
                            }
                        });
                    } else if (!multiplesGroup) {
                        // Regular child - add just this one
                        if (!allChildren.includes(child)) {
                            allChildren.push(child);
                        }
                    }
                });

                // Now check if all these children form a single multiples group
                if (allChildren.length >= 2) {
                    childTarget = multiplesConnections.find(multConn => {
                        return allChildren.every(child => multConn.multiples.includes(child)) &&
                               multConn.multiples.every(mult => allChildren.includes(mult));
                    });

                    if (!childTarget) {
                        // Check for existing sibling connection
                        childTarget = siblingConnections.find(sibConn => {
                            return allChildren.every(child => sibConn.siblings.includes(child)) &&
                                   sibConn.siblings.every(sib => allChildren.includes(sib));
                        });

                        if (!childTarget) {
                            // Check if any child is already in a sibling group
                            const existingConnection = siblingConnections.find(sibConn => {
                                return allChildren.some(child => sibConn.siblings.includes(child));
                            });

                            if (existingConnection) {
                                // Merge with existing sibling group - ensure ALL children are included
                                const newSiblings = [...new Set([...existingConnection.siblings, ...allChildren])];
                                existingConnection.siblings = newSiblings;
                                childTarget = existingConnection;
                            } else {
                                // Create new sibling connection with ALL children
                                childTarget = new SiblingConnection(allChildren);
                                siblingConnections.push(childTarget);
                            }
                        }
                    }
                }
            } else if (children.length === 1) {
                // Single child - check if part of multiples group
                const multiplesGroup = multiplesConnections.find(multConn =>
                    multConn.multiples.includes(children[0])
                );

                if (multiplesGroup) {
                    // Use the multiples group
                    childTarget = multiplesGroup;
                } else {
                    // Use the Individual directly
                    childTarget = children[0];
                }
            }

            // Create parent-child connection if both exist
            if (parentSource && childTarget) {
                // Check if this connection already exists
                const existingParentSiblingConnection = parentSiblingConnections.find(psConn =>
                    psConn.parentSource === parentSource &&
                    psConn.childTarget === childTarget
                );

                if (!existingParentSiblingConnection) {
                    const parentSiblingConnection = new ParentSiblingConnection(parentSource, childTarget);
                    parentSiblingConnections.push(parentSiblingConnection);
                }
            }

            // Clear selections
            selectedIndividuals.forEach(ind => ind.selected = false);
            selectedIndividuals = [];

            // Update button visibility
            updateFamilyConnectionButton();

            // Show success message
            const parentCount = parents.length;
            const childCount = children.length;
            showBriefMessage(`Family connected: ${parentCount} parent${parentCount !== 1 ? 's' : ''} and ${childCount} child${childCount !== 1 ? 'ren' : ''}`);

            draw();
        }

        // Donor Symbol Functions
        function addDonorToPregnancy(pregnancySymbol, donorType) {
            // Save state before adding
            saveState();
            
            // Calculate position for the donor symbol
            const donorDistance = 60; // Distance from pregnancy symbol
            let donorX, donorY;
            
            if (donorType === 'egg') {
                // Position egg donor to the upper left of pregnancy
                donorX = pregnancySymbol.x - donorDistance;
                donorY = pregnancySymbol.y - donorDistance;
            } else { // sperm donor
                // Position sperm donor to the upper right of pregnancy
                donorX = pregnancySymbol.x + donorDistance;
                donorY = pregnancySymbol.y - donorDistance;
            }
            
            // Ensure donor stays within canvas bounds
            const canvasWidth = canvas.width / window.devicePixelRatio;
            const canvasHeight = canvas.height / window.devicePixelRatio;
            donorX = Math.max(SYMBOL_RADIUS + 10, Math.min(donorX, canvasWidth - SYMBOL_RADIUS - 10));
            donorY = Math.max(SYMBOL_RADIUS + 10, Math.min(donorY, canvasHeight - SYMBOL_RADIUS - 10));
            
            // Create the donor symbol
            const donorId = Date.now() + Math.random();
            const donorSymbolType = donorType === 'egg' ? 'female' : 'male';
            const donor = new Individual(donorX, donorY, donorSymbolType, donorId);
            
            // Set donor-specific properties
            donor.fillChar = 'D'; // Fill with "D" to indicate donor
            donor.name = donorType === 'egg' ? 'Egg Donor' : 'Sperm Donor';
            donor.showName = true;
            
            individuals.push(donor);
            
            // Create connection from donor to pregnancy symbol
            // Connect to the tip of the pregnancy diamond (top point)
            const donorConnection = new Connection(donor, pregnancySymbol, 'donor');
            connections.push(donorConnection);
            
            // Select the new donor for easy editing
            individuals.forEach(ind => ind.selected = false);
            connections.forEach(conn => conn.selected = false);
            textBoxes.forEach(tb => tb.selected = false);
            selectedIndividuals = [];
            
            donor.selected = true;
            selectedIndividuals.push(donor);
            
            draw();
            
            // Show brief message
            const pregnancyName = pregnancySymbol.name || 'pregnancy';
            showBriefMessage(`Added ${donorType} donor to ${pregnancyName}`);
        }

        // Enhanced symbol drag and drop functionality
        function initSymbolDragAndDrop() {
            const symbolButtons = [
                { id: 'btn-male', type: 'male', name: 'Male' },
                { id: 'btn-female', type: 'female', name: 'Female' },
                { id: 'btn-unknown', type: 'unknown', name: 'Unknown' },
                { id: 'btn-miscarriage', type: 'miscarriage', name: 'Miscarriage' },
                { id: 'btn-pregnancy', type: 'pregnancy', name: 'Pregnancy' },
                { id: 'btn-ectopic', type: 'ectopic', name: 'Ectopic Pregnancy' },
                { id: 'btn-tab', type: 'tab', name: 'TAB' },
                { id: 'btn-proband', type: 'proband', name: 'Proband' },
                { id: 'btn-separated', type: 'separated', name: 'Separation Symbol' }
            ];

            symbolButtons.forEach(({ id, type, name }) => {
                const button = document.getElementById(id);
                if (button) {
                    // Make button draggable
                    button.draggable = true;
                    
                    // Add visual feedback on hover
                    button.addEventListener('mouseenter', () => {
                        if (!isDraggingSymbol) {
                            button.style.cursor = 'grab';
                            button.style.transform = 'scale(1.05)';
                            button.style.transition = 'transform 0.2s ease';
                        }
                    });
                    
                    button.addEventListener('mouseleave', () => {
                        if (!isDraggingSymbol) {
                            button.style.cursor = 'pointer';
                            button.style.transform = 'scale(1)';
                        }
                    });

                    // Handle drag start
                    button.addEventListener('dragstart', (e) => {
                        isDraggingSymbol = true;
                        draggedSymbolType = type;
                        
                        // Set drag effect
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', type);
                        
                        // Visual feedback during drag
                        button.style.cursor = 'grabbing';
                        button.style.transform = 'scale(0.95)';
                        button.style.opacity = '0.7';
                        
                        // Create and set custom drag preview
                        createDragPreview(type, e);
                        
                        // Show drag feedback
                        showDragFromToolbarFeedback(name);
                        
                        // Add visual indicator to canvas
                        canvas.style.backgroundColor = 'rgba(93, 92, 222, 0.05)';
                        canvas.style.transition = 'background-color 0.2s ease';
                    });

                    // Handle drag end
                    button.addEventListener('dragend', (e) => {
                        isDraggingSymbol = false;
                        draggedSymbolType = null;
                        
                        // Reset button appearance
                        button.style.cursor = 'pointer';
                        button.style.transform = 'scale(1)';
                        button.style.opacity = '1';
                        button.style.transition = 'all 0.2s ease';
                        
                        // Reset canvas appearance
                        canvas.style.backgroundColor = '';
                        canvas.style.transition = '';
                        
                        // Hide drag feedback
                        hideDragFromToolbarFeedback();
                        
                        // Clean up drag preview
                        if (dragPreview && dragPreview.parentNode) {
                            dragPreview.parentNode.removeChild(dragPreview);
                        }
                        dragPreview = null;
                    });
                }
            });

            // Add text box button to draggable items
            const textBoxButton = document.getElementById('btn-textbox');
            if (textBoxButton) {
                textBoxButton.draggable = true;
                
                textBoxButton.addEventListener('mouseenter', () => {
                    if (!isDraggingSymbol) {
                        textBoxButton.style.cursor = 'grab';
                        textBoxButton.style.transform = 'scale(1.05)';
                        textBoxButton.style.transition = 'transform 0.2s ease';
                    }
                });
                
                textBoxButton.addEventListener('mouseleave', () => {
                    if (!isDraggingSymbol) {
                        textBoxButton.style.cursor = 'pointer';
                        textBoxButton.style.transform = 'scale(1)';
                    }
                });

                textBoxButton.addEventListener('dragstart', (e) => {
                    isDraggingSymbol = true;
                    draggedSymbolType = 'textbox';
                    
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', 'textbox');
                    
                    textBoxButton.style.cursor = 'grabbing';
                    textBoxButton.style.transform = 'scale(0.95)';
                    textBoxButton.style.opacity = '0.7';
                    
                    showDragFromToolbarFeedback('Text Box');
                    canvas.style.backgroundColor = 'rgba(93, 92, 222, 0.05)';
                    canvas.style.transition = 'background-color 0.2s ease';
                });

                textBoxButton.addEventListener('dragend', (e) => {
                    isDraggingSymbol = false;
                    draggedSymbolType = null;
                    
                    textBoxButton.style.cursor = 'pointer';
                    textBoxButton.style.transform = 'scale(1)';
                    textBoxButton.style.opacity = '1';
                    textBoxButton.style.transition = 'all 0.2s ease';
                    
                    canvas.style.backgroundColor = '';
                    canvas.style.transition = '';
                    hideDragFromToolbarFeedback();
                });
            }

            // Handle canvas drop events
            canvas.addEventListener('dragover', (e) => {
                if (isDraggingSymbol) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    
                    // Visual feedback on canvas during drag over
                    canvas.style.cursor = 'copy';
                }
            });

            canvas.addEventListener('dragenter', (e) => {
                if (isDraggingSymbol) {
                    e.preventDefault();
                }
            });

            canvas.addEventListener('dragleave', (e) => {
                if (isDraggingSymbol) {
                    canvas.style.cursor = 'default';
                }
            });

            canvas.addEventListener('drop', (e) => {
                if (isDraggingSymbol && draggedSymbolType) {
                    e.preventDefault();
                    
                    const coords = getCanvasCoordinates(e);
                    
                    // Add the symbol at the drop location
                    if (draggedSymbolType === 'textbox') {
                        addTextBox(coords.x, coords.y);
                        showBriefMessage(`Added text box at (${Math.round(coords.x)}, ${Math.round(coords.y)})`);
                    } else if (draggedSymbolType === 'proband') {
                        addProbandArrow(coords.x, coords.y);
                        showBriefMessage(`Added proband arrow at (${Math.round(coords.x)}, ${Math.round(coords.y)})`);
                    } else if (draggedSymbolType === 'separated') {
                        addSeparationSymbol(coords.x, coords.y);
                        showBriefMessage(`Added separation symbol at (${Math.round(coords.x)}, ${Math.round(coords.y)})`);
                    } else {
                        addIndividual(coords.x, coords.y, draggedSymbolType);
                        const symbolName = getSymbolDisplayName(draggedSymbolType);
                        showBriefMessage(`Added ${symbolName} at (${Math.round(coords.x)}, ${Math.round(coords.y)})`);
                    }
                    
                    // Reset canvas cursor
                    canvas.style.cursor = 'default';
                }
            });
        }

        // Initialize draggable tools panel
        function initToolsPanelDrag() {
            const toolsPanel = document.getElementById('draggable-tools');
            const dragHandle = document.getElementById('tools-drag-handle');

            if (!toolsPanel || !dragHandle) return;

            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            // Get initial position from current styles
            const computedStyle = window.getComputedStyle(toolsPanel);
            const initialLeft = parseInt(computedStyle.left) || 16;
            const initialTop = parseInt(computedStyle.top) || 320;
            xOffset = initialLeft;
            yOffset = initialTop;

            dragHandle.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            // Touch events for mobile
            dragHandle.addEventListener('touchstart', dragStart);
            document.addEventListener('touchmove', drag);
            document.addEventListener('touchend', dragEnd);

            function dragStart(e) {
                // Only allow dragging from the handle
                if (e.type === 'touchstart') {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }

                if (e.target === dragHandle) {
                    isDragging = true;
                    toolsPanel.style.transition = 'none';
                    dragHandle.style.cursor = 'grabbing';
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();

                    if (e.type === 'touchmove') {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }

                    xOffset = currentX;
                    yOffset = currentY;

                    // Keep panel within viewport bounds
                    const rect = toolsPanel.getBoundingClientRect();
                    const maxX = window.innerWidth - rect.width;
                    const maxY = window.innerHeight - rect.height;

                    xOffset = Math.max(0, Math.min(xOffset, maxX));
                    yOffset = Math.max(0, Math.min(yOffset, maxY));

                    setTranslate(xOffset, yOffset, toolsPanel);
                }
            }

            function dragEnd(e) {
                if (isDragging) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    dragHandle.style.cursor = 'move';
                }
            }

            function setTranslate(xPos, yPos, el) {
                el.style.left = xPos + 'px';
                el.style.top = yPos + 'px';
            }
        }

        function createDragPreview(symbolType, dragEvent) {
            // Create a canvas element for the drag preview
            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = SYMBOL_SIZE + 10;
            previewCanvas.height = SYMBOL_SIZE + 10;
            const previewCtx = previewCanvas.getContext('2d');
            
            // Style the preview canvas
            previewCanvas.style.position = 'absolute';
            previewCanvas.style.pointerEvents = 'none';
            previewCanvas.style.zIndex = '9999';
            previewCanvas.style.opacity = '0.8';
            
            // Draw the symbol preview
            const centerX = (SYMBOL_SIZE + 10) / 2;
            const centerY = (SYMBOL_SIZE + 10) / 2;
            
            const isDark = document.documentElement.classList.contains('dark');
            previewCtx.strokeStyle = '#5D5CDE'; // Use primary color for preview
            previewCtx.fillStyle = '#5D5CDE';
            previewCtx.lineWidth = 3;

            switch (symbolType) {
                case 'male':
                    previewCtx.strokeRect(centerX - SYMBOL_RADIUS, centerY - SYMBOL_RADIUS, SYMBOL_SIZE, SYMBOL_SIZE);
                    break;
                case 'female':
                    previewCtx.beginPath();
                    previewCtx.arc(centerX, centerY, SYMBOL_RADIUS, 0, 2 * Math.PI);
                    previewCtx.stroke();
                    break;
                case 'unknown':
                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX, centerY - SYMBOL_RADIUS);
                    previewCtx.lineTo(centerX + SYMBOL_RADIUS, centerY);
                    previewCtx.lineTo(centerX, centerY + SYMBOL_RADIUS);
                    previewCtx.lineTo(centerX - SYMBOL_RADIUS, centerY);
                    previewCtx.closePath();
                    previewCtx.stroke();
                    break;
                case 'miscarriage':
                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX, centerY - SYMBOL_RADIUS);
                    previewCtx.lineTo(centerX + SYMBOL_RADIUS, centerY + SYMBOL_RADIUS);
                    previewCtx.lineTo(centerX - SYMBOL_RADIUS, centerY + SYMBOL_RADIUS);
                    previewCtx.closePath();
                    previewCtx.stroke();
                    break;
                case 'pregnancy':
                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX, centerY - SYMBOL_RADIUS);
                    previewCtx.lineTo(centerX + SYMBOL_RADIUS, centerY);
                    previewCtx.lineTo(centerX, centerY + SYMBOL_RADIUS);
                    previewCtx.lineTo(centerX - SYMBOL_RADIUS, centerY);
                    previewCtx.closePath();
                    previewCtx.stroke();
                    
                    // Draw the "P" inside the diamond
                    previewCtx.font = 'bold 14px Arial';
                    previewCtx.textAlign = 'center';
                    previewCtx.textBaseline = 'middle';
                    previewCtx.fillText('P', centerX, centerY);
                    break;
                case 'ectopic':
                    previewCtx.beginPath();
                    previewCtx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
                    previewCtx.fill();
                    break;
                case 'tab':
                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX, centerY - SYMBOL_RADIUS);
                    previewCtx.lineTo(centerX + SYMBOL_RADIUS, centerY + SYMBOL_RADIUS);
                    previewCtx.lineTo(centerX - SYMBOL_RADIUS, centerY + SYMBOL_RADIUS);
                    previewCtx.closePath();
                    previewCtx.stroke();
                    
                    // Draw deceased slash
                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX - SYMBOL_RADIUS - 2, centerY + SYMBOL_RADIUS + 2);
                    previewCtx.lineTo(centerX + SYMBOL_RADIUS + 2, centerY - SYMBOL_RADIUS - 2);
                    previewCtx.stroke();
                    break;
                case 'proband':
                    // Draw arrow
                    const startX = centerX - 8, startY = centerY + 8;
                    const endX = centerX + 8, endY = centerY - 8;
                    
                    previewCtx.beginPath();
                    previewCtx.moveTo(startX, startY);
                    previewCtx.lineTo(endX, endY);
                    previewCtx.stroke();
                    
                    // Draw arrowhead
                    const arrowHeadLength = 6;
                    const angle = Math.atan2(endY - startY, endX - startX);
                    const arrowHeadAngle = Math.PI / 6;
                    
                    const leftHeadX = endX - arrowHeadLength * Math.cos(angle - arrowHeadAngle);
                    const leftHeadY = endY - arrowHeadLength * Math.sin(angle - arrowHeadAngle);
                    const rightHeadX = endX - arrowHeadLength * Math.cos(angle + arrowHeadAngle);
                    const rightHeadY = endY - arrowHeadLength * Math.sin(angle + arrowHeadAngle);
                    
                    previewCtx.beginPath();
                    previewCtx.moveTo(endX, endY);
                    previewCtx.lineTo(leftHeadX, leftHeadY);
                    previewCtx.lineTo(rightHeadX, rightHeadY);
                    previewCtx.closePath();
                    previewCtx.fill();
                    break;
            }
            
            // Set the custom drag image
            dragEvent.dataTransfer.setDragImage(previewCanvas, centerX, centerY);
            
            // Store reference for cleanup
            dragPreview = previewCanvas;
        }

        // Drag feedback functions
        function showDragFeedback(type, count, itemType = '') {
            // Create or update drag feedback element
            let feedback = document.getElementById('dragFeedback');
            if (!feedback) {
                feedback = document.createElement('div');
                feedback.id = 'dragFeedback';
                feedback.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-primary text-white px-4 py-2 rounded-lg shadow-lg z-50 text-sm font-medium pointer-events-none';
                document.body.appendChild(feedback);
            }
            
            let message = '';
            if (type === 'group') {
                message = `Moving ${count} selected items`;
            } else {
                const typeDisplay = itemType ? ` ${itemType}` : '';
                message = `Moving${typeDisplay} symbol`;
            }
            
            feedback.textContent = message;
            feedback.style.display = 'block';
            
            // Add animation
            feedback.style.transform = 'translate(-50%, -20px)';
            feedback.style.opacity = '0';
            
            requestAnimationFrame(() => {
                feedback.style.transition = 'all 0.2s ease-out';
                feedback.style.transform = 'translate(-50%, 0)';
                feedback.style.opacity = '1';
            });
        }
        
        function hideDragFeedback() {
            const feedback = document.getElementById('dragFeedback');
            if (feedback) {
                feedback.style.transition = 'all 0.2s ease-in';
                feedback.style.transform = 'translate(-50%, -20px)';
                feedback.style.opacity = '0';
                
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                }, 200);
            }
        }

        // Toolbar drag feedback functions
        function showDragFromToolbarFeedback(symbolName) {
            // Create or update toolbar drag feedback element
            let feedback = document.getElementById('toolbarDragFeedback');
            if (!feedback) {
                feedback = document.createElement('div');
                feedback.id = 'toolbarDragFeedback';
                feedback.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 text-sm font-medium pointer-events-none';
                document.body.appendChild(feedback);
            }
            
            feedback.textContent = `Dragging ${symbolName} - Drop on canvas to place`;
            feedback.style.display = 'block';
            
            // Add animation
            feedback.style.transform = 'translate(-50%, -20px)';
            feedback.style.opacity = '0';
            
            requestAnimationFrame(() => {
                feedback.style.transition = 'all 0.2s ease-out';
                feedback.style.transform = 'translate(-50%, 0)';
                feedback.style.opacity = '1';
            });
        }
        
        function hideDragFromToolbarFeedback() {
            const feedback = document.getElementById('toolbarDragFeedback');
            if (feedback) {
                feedback.style.transition = 'all 0.2s ease-in';
                feedback.style.transform = 'translate(-50%, -20px)';
                feedback.style.opacity = '0';
                
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                }, 200);
            }
        }

        // Symbol display name helper
        function getSymbolDisplayName(symbolType) {
            const displayNames = {
                'male': 'Male',
                'female': 'Female', 
                'unknown': 'Unknown',
                'miscarriage': 'Miscarriage',
                'pregnancy': 'Pregnancy',
                'ectopic': 'Ectopic Pregnancy',
                'tab': 'TAB',
                'proband': 'Proband Arrow',
                'textbox': 'Text Box'
            };
            return displayNames[symbolType] || symbolType;
        }

        // Ectopic Modal Functions
        function openEctopicModal(ectopicIndividual) {
            currentIndividualId = ectopicIndividual.id;
            
            // Set the ectopic-specific fields with current values
            document.getElementById('ectopicYear').value = ectopicIndividual.year || '';
            document.getElementById('ectopicComments').value = ectopicIndividual.comments || '';
            
            document.getElementById('ectopicModal').classList.remove('hidden');
        }

        function closeEctopicModal() {
            document.getElementById('ectopicModal').classList.add('hidden');
            currentIndividualId = null;
        }

        function saveEctopicInfo() {
            if (currentIndividualId) {
                const ectopicIndividual = individuals.find(ind => ind.id === currentIndividualId);
                if (ectopicIndividual) {
                    // Save state before making changes
                    saveState();
                    
                    // Get the ectopic-specific values from the inputs
                    ectopicIndividual.year = document.getElementById('ectopicYear').value;
                    ectopicIndividual.comments = document.getElementById('ectopicComments').value;
                    
                    draw();
                }
            }
            closeEctopicModal();
        }

        // Miscarriage Modal Functions
        function openMiscarriageModal(miscarriageIndividual) {
            currentIndividualId = miscarriageIndividual.id;
            
            // Set the miscarriage-specific fields with current values
            document.getElementById('miscarriageGestation').value = miscarriageIndividual.weeksGestation || '';
            
            // Set fetal anomalies radio button
            if (miscarriageIndividual.fetalAnomalies === 'yes') {
                document.getElementById('fetalAnomaliesYes').checked = true;
            } else if (miscarriageIndividual.fetalAnomalies === 'no') {
                document.getElementById('fetalAnomaliesNo').checked = true;
            } else if (miscarriageIndividual.fetalAnomalies === 'unknown') {
                document.getElementById('fetalAnomaliesUnknown').checked = true;
            }
            
            document.getElementById('miscarriageComments').value = miscarriageIndividual.miscarriageComments || '';
            
            // Set display options
            document.getElementById('showMiscarriageGestation').checked = miscarriageIndividual.showMiscarriageGestation || false;
            document.getElementById('showFetalAnomalies').checked = miscarriageIndividual.showFetalAnomalies || false;
            document.getElementById('showMiscarriageComments').checked = miscarriageIndividual.showMiscarriageComments || false;
            
            document.getElementById('miscarriageModal').classList.remove('hidden');
        }

        function closeMiscarriageModal() {
            document.getElementById('miscarriageModal').classList.add('hidden');
            currentIndividualId = null;
        }

        function saveMiscarriageInfo() {
            if (currentIndividualId) {
                const miscarriageIndividual = individuals.find(ind => ind.id === currentIndividualId);
                if (miscarriageIndividual) {
                    // Save state before making changes
                    saveState();
                    
                    // Get the miscarriage-specific values from the inputs
                    miscarriageIndividual.weeksGestation = document.getElementById('miscarriageGestation').value;
                    miscarriageIndividual.miscarriageComments = document.getElementById('miscarriageComments').value;
                    
                    // Get fetal anomalies selection
                    if (document.getElementById('fetalAnomaliesYes').checked) {
                        miscarriageIndividual.fetalAnomalies = 'yes';
                    } else if (document.getElementById('fetalAnomaliesNo').checked) {
                        miscarriageIndividual.fetalAnomalies = 'no';
                    } else if (document.getElementById('fetalAnomaliesUnknown').checked) {
                        miscarriageIndividual.fetalAnomalies = 'unknown';
                    }
                    
                    // Set display options
                    miscarriageIndividual.showMiscarriageGestation = document.getElementById('showMiscarriageGestation').checked;
                    miscarriageIndividual.showFetalAnomalies = document.getElementById('showFetalAnomalies').checked;
                    miscarriageIndividual.showMiscarriageComments = document.getElementById('showMiscarriageComments').checked;
                    
                    draw();
                }
            }
            closeMiscarriageModal();
        }

        // Instructions Modal Functions
        function openInstructionsModal() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }

        function closeInstructionsModal() {
            document.getElementById('instructionsModal').classList.add('hidden');
        }

        // User Guide Tab Switching
        function switchUserGuideTab(tabName) {
            // Hide all content sections
            const contents = document.querySelectorAll('.user-guide-content');
            contents.forEach(content => content.classList.add('hidden'));

            // Remove active state from all tabs
            const tabs = document.querySelectorAll('.user-guide-tab');
            tabs.forEach(tab => {
                tab.classList.remove('border-primary', 'text-primary');
                tab.classList.add('border-transparent', 'text-gray-600', 'dark:text-gray-400');
            });

            // Show selected content
            document.getElementById('content-' + tabName).classList.remove('hidden');

            // Activate selected tab
            const activeTab = document.getElementById('tab-' + tabName);
            activeTab.classList.add('border-primary', 'text-primary');
            activeTab.classList.remove('border-transparent', 'text-gray-600', 'dark:text-gray-400');
        }

        // Download User Guide as PDF
        async function downloadUserGuidePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });

            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const margin = 15;
            const contentWidth = pageWidth - (2 * margin);
            let yPos = margin;

            // Helper function to add new page if needed
            function checkPageBreak(neededSpace) {
                if (yPos + neededSpace > pageHeight - margin) {
                    doc.addPage();
                    yPos = margin;
                    return true;
                }
                return false;
            }

            // Helper function to add wrapped text
            function addWrappedText(text, x, y, maxWidth, fontSize, isBold = false) {
                doc.setFontSize(fontSize);
                doc.setFont('helvetica', isBold ? 'bold' : 'normal');
                const lines = doc.splitTextToSize(text, maxWidth);
                lines.forEach((line, index) => {
                    checkPageBreak(7);
                    doc.text(line, x, y + (index * 6));
                    yPos = y + (index * 6) + 6;
                });
                return yPos;
            }

            // Title
            doc.setFontSize(24);
            doc.setFont('helvetica', 'bold');
            doc.text('User Guide', margin, yPos);
            yPos += 10;

            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text('Fast Family Tree Maker', margin, yPos);
            yPos += 15;

            // Getting Started Section
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('Getting Started', margin, yPos);
            yPos += 10;

            // Welcome message
            doc.setFontSize(10);
            doc.setFont('helvetica', 'italic');
            yPos = addWrappedText('Welcome to Fast Family Tree Maker! This application helps you create professional pedigree charts for medical and genetic documentation.', margin, yPos, contentWidth, 10);
            yPos += 8;

            // Adding Symbols
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Adding Symbols', margin, yPos);
            yPos += 6;

            const addingSymbolsPoints = [
                'Click & Place: Click a tool button in the toolbar, then click on the canvas where you want to place the symbol',
                'Drag & Drop: Drag symbols directly from the toolbar onto the canvas for quick placement',
                'Right-Click Menu: Right-click empty space on the canvas for a quick symbol placement menu',
                'Auto-Snapping: Symbols automatically align to generation lines when placed to maintain proper alignment'
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            addingSymbolsPoints.forEach(point => {
                checkPageBreak(10);
                yPos = addWrappedText('‚Ä¢ ' + point, margin + 5, yPos, contentWidth - 5, 10);
                yPos += 2;
            });
            yPos += 6;

            // Creating Relationships
            checkPageBreak(30);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Creating Relationships', margin, yPos);
            yPos += 6;

            const relationshipsPoints = [
                'Marriage: Select 2 partners (by drag-selecting or with Marriage tool), then click the "Marriage" button to create a partnership line',
                'Consanguineous: Select 2 blood relatives, then click "Consanguineous" to create a double-line connection',
                'Adjusting Connections: Select a marriage or consanguineous line, then drag the middle handle to adjust the angle and length',
                'Offspring: Select children on the same generation line, then click "Offspring" to connect them to their parents above',
                'Family Connection: Select parents and children together, then click "Connect as Family" for automatic setup of both marriage and offspring relationships',
                'Donors: Right-click pregnancy symbols to add egg or sperm donors with automatic connection lines'
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            relationshipsPoints.forEach(point => {
                checkPageBreak(10);
                yPos = addWrappedText('‚Ä¢ ' + point, margin + 5, yPos, contentWidth - 5, 10);
                yPos += 2;
            });
            yPos += 6;

            // Navigation & Selection
            checkPageBreak(30);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Navigation & Selection', margin, yPos);
            yPos += 6;

            const navigationPoints = [
                'Move: Click and drag any symbol or selected group to reposition it on the canvas',
                'Multi-Select: Drag on empty space to create a selection rectangle around multiple items',
                'Add to Selection: Hold Ctrl and click items to add or remove them from the current selection',
                'Select All: Press Ctrl+A to select all items on the canvas at once',
                'Copy/Paste: Use Ctrl+C/Ctrl+V, toolbar buttons, or right-click menu to duplicate items'
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            navigationPoints.forEach(point => {
                checkPageBreak(10);
                yPos = addWrappedText('‚Ä¢ ' + point, margin + 5, yPos, contentWidth - 5, 10);
                yPos += 2;
            });
            yPos += 6;

            // Best Practices
            checkPageBreak(30);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Best Practices', margin, yPos);
            yPos += 6;

            const bestPracticesPoints = [
                'Follow standard conventions: males on left, females on right, oldest to youngest from left to right',
                'Use generation lines to keep family members properly aligned vertically',
                'Save your work regularly using the Save Canvas button',
                'Create disorder patterns in the legend before assigning them to individuals',
                'Use text boxes for additional notes, dates, or clinical information',
                'Test your saved files periodically to ensure they load correctly'
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            bestPracticesPoints.forEach(point => {
                checkPageBreak(10);
                yPos = addWrappedText('‚Ä¢ ' + point, margin + 5, yPos, contentWidth - 5, 10);
                yPos += 2;
            });
            yPos += 10;

            // Features Section
            checkPageBreak(30);
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('Features', margin, yPos);
            yPos += 10;

            // Editing & Customization
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Editing & Customization', margin, yPos);
            yPos += 6;

            const editingPoints = [
                'Edit Details: Double-click any symbol or text box to open the edit dialog, or use the right-click context menu',
                'Deceased Status: Use the Deceased tool to click symbols and toggle the diagonal slash indicator',
                'Delete Items: Select items and press Delete or Backspace, click the Delete button, or use the right-click menu',
                'Disorder Patterns: Create custom patterns in the legend panel, then assign them to specific quadrants of symbols when editing',
                'Text Boxes: Add notes, labels, and clinical information anywhere on the canvas using text boxes',
                'Resize Text Boxes: Click and drag the corner handles of any text box to resize it'
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            editingPoints.forEach(point => {
                checkPageBreak(10);
                yPos = addWrappedText('‚Ä¢ ' + point, margin + 5, yPos, contentWidth - 5, 10);
                yPos += 2;
            });
            yPos += 6;

            // File Management & Export
            checkPageBreak(40);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('File Management & Export', margin, yPos);
            yPos += 6;

            const fileManagementPoints = [
                'Save Canvas: Downloads your family tree as a JSON file that preserves all data including individuals, connections, text boxes, and disorder patterns. Use this to backup your work or share editable versions.',
                'Load Canvas: Opens a saved JSON file to restore a previously created family tree. All data including names, birth years, patterns, and relationships will be restored exactly as saved.',
                'Download PDF: Creates a professional PDF document of your family tree with symbol legend and pattern definitions. Perfect for printing, sharing with medical professionals, or archiving.',
                'File Compatibility: Save files (.json) are only compatible with this application. PDF files are universally readable but cannot be edited.',
                'Backup Recommendations: Save your work regularly and keep multiple backup files, especially for complex family trees with extensive medical histories.'
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            fileManagementPoints.forEach(point => {
                checkPageBreak(15);
                yPos = addWrappedText('‚Ä¢ ' + point, margin + 5, yPos, contentWidth - 5, 10);
                yPos += 2;
            });
            yPos += 6;

            // Special Features
            checkPageBreak(30);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Special Features', margin, yPos);
            yPos += 6;

            const specialFeaturesPoints = [
                'Auto-Snapping: Symbols automatically align to generation lines for consistent vertical positioning',
                'Pattern System: Create custom disorder patterns with various fill styles in the legend, then apply them to any quadrant of a symbol',
                'Group Operations: Select multiple items to perform batch operations like moving, copying, or deleting while preserving relationships',
                'Relationship Preservation: When copying and pasting groups, all relationships between items are maintained',
                'Undo/Redo: Press Ctrl+Z to undo your last action (up to 50 actions can be undone)'
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            specialFeaturesPoints.forEach(point => {
                checkPageBreak(10);
                yPos = addWrappedText('‚Ä¢ ' + point, margin + 5, yPos, contentWidth - 5, 10);
                yPos += 2;
            });
            yPos += 10;

            // Keyboard Shortcuts Section
            checkPageBreak(30);
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('Keyboard Shortcuts', margin, yPos);
            yPos += 10;

            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Keyboard Shortcuts', margin, yPos);
            yPos += 6;

            const shortcuts = [
                ['Copy selected items', 'Ctrl+C'],
                ['Paste from clipboard', 'Ctrl+V'],
                ['Select all items', 'Ctrl+A'],
                ['Undo last action', 'Ctrl+Z'],
                ['Delete selected items', 'Delete / Backspace'],
                ['Close modal/dialog', 'Esc']
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            shortcuts.forEach(([action, key]) => {
                checkPageBreak(8);
                doc.text('‚Ä¢ ' + action + ': ', margin + 5, yPos);
                doc.setFont('helvetica', 'bold');
                doc.text(key, margin + 70, yPos);
                doc.setFont('helvetica', 'normal');
                yPos += 6;
            });
            yPos += 6;

            // Mouse Interactions
            checkPageBreak(30);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Mouse Interactions', margin, yPos);
            yPos += 6;

            const mouseActions = [
                ['Edit individual/text box', 'Double-click'],
                ['Open context menu', 'Right-click'],
                ['Multi-select rectangle', 'Drag on empty space'],
                ['Add to selection', 'Ctrl+Click'],
                ['Move symbols/groups', 'Click & Drag'],
                ['Resize text box', 'Drag corner handles']
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            mouseActions.forEach(([action, method]) => {
                checkPageBreak(8);
                doc.text('‚Ä¢ ' + action + ': ', margin + 5, yPos);
                doc.setFont('helvetica', 'bold');
                doc.text(method, margin + 70, yPos);
                doc.setFont('helvetica', 'normal');
                yPos += 6;
            });
            yPos += 6;

            // Quick Actions
            checkPageBreak(30);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Quick Actions', margin, yPos);
            yPos += 6;

            const quickActions = [
                ['Right-click on empty space', 'Quick symbol placement menu for adding individuals'],
                ['Right-click on individuals', 'Access edit, delete, copy, and other context options'],
                ['Right-click on pregnancy symbols', 'Add egg or sperm donors with automatic connection lines'],
                ['Drag from toolbar', 'Click and drag symbols from the toolbar directly onto the canvas for quick placement'],
                ['Family Connection button', 'Appears when valid family is selected - Creates marriage and offspring connections in one click']
            ];

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            quickActions.forEach(([action, description]) => {
                checkPageBreak(15);
                doc.setFont('helvetica', 'bold');
                yPos = addWrappedText('‚Ä¢ ' + action, margin + 5, yPos, contentWidth - 5, 10, true);
                doc.setFont('helvetica', 'normal');
                yPos = addWrappedText('  ' + description, margin + 5, yPos, contentWidth - 5, 10);
                yPos += 2;
            });

            // Save the PDF
            doc.save('Fast_Family_Tree_User_Guide.pdf');
        }

        // Feedback Modal Functions
        const DEVELOPER_EMAIL = 'info@genescreen.ca';

        function openFeedbackModal() {
            document.getElementById('feedbackModal').classList.remove('hidden');
        }

        function closeFeedbackModal() {
            document.getElementById('feedbackModal').classList.add('hidden');
            hideFeedbackStatus();
        }

        function copyFeedbackNotes() {
            const notes = document.getElementById('feedbackNotes').value;
            if (!notes.trim()) {
                showFeedbackStatus('No notes to copy. Please write some feedback first.', 'warning');
                return;
            }

            navigator.clipboard.writeText(notes).then(() => {
                showFeedbackStatus('‚úì Notes copied to clipboard!', 'success');
            }).catch(err => {
                showFeedbackStatus('Failed to copy notes. Please try again.', 'error');
                console.error('Copy failed:', err);
            });
        }

        function emailFeedback() {
            const notes = document.getElementById('feedbackNotes').value;
            const email = DEVELOPER_EMAIL;
            const subject = 'Fast Family Tree - Beta Feedback';

            // Use notes if available, otherwise provide template
            const body = notes.trim() || 'Hi! Here is my feedback:\n\n[Please describe your experience, bugs found, or feature requests]\n\nThank you!';

            // Create mailto link with encoded parameters
            const mailtoLink = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

            // Create a temporary anchor element and click it (more reliable than window.location)
            const anchor = document.createElement('a');
            anchor.href = mailtoLink;
            anchor.target = '_blank';
            anchor.style.display = 'none';
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);

            // Show confirmation message
            showFeedbackStatus('‚úì Opening your email client...', 'success');
        }

        function copyDeveloperEmail() {
            navigator.clipboard.writeText(DEVELOPER_EMAIL).then(() => {
                showFeedbackStatus(`‚úì Email copied: ${DEVELOPER_EMAIL}`, 'success');
            }).catch(err => {
                showFeedbackStatus('Failed to copy email. Please try again.', 'error');
                console.error('Copy failed:', err);
            });
        }

        function clearFeedbackNotes() {
            const confirmClear = () => {
                document.getElementById('feedbackNotes').value = '';
                showFeedbackStatus('‚úì Notes cleared', 'success');
            };

            showConfirmDialog('Are you sure you want to clear all your feedback notes? This cannot be undone.', confirmClear);
        }

        function showFeedbackStatus(message, type) {
            const status = document.getElementById('feedbackCopyStatus');
            status.textContent = message;
            status.classList.remove('hidden', 'bg-green-100', 'bg-red-100', 'bg-yellow-100',
                                    'text-green-800', 'text-red-800', 'text-yellow-800',
                                    'dark:bg-green-900/20', 'dark:bg-red-900/20', 'dark:bg-yellow-900/20',
                                    'dark:text-green-300', 'dark:text-red-300', 'dark:text-yellow-300');

            if (type === 'success') {
                status.classList.add('bg-green-100', 'dark:bg-green-900/20', 'text-green-800', 'dark:text-green-300');
            } else if (type === 'error') {
                status.classList.add('bg-red-100', 'dark:bg-red-900/20', 'text-red-800', 'dark:text-red-300');
            } else if (type === 'warning') {
                status.classList.add('bg-yellow-100', 'dark:bg-yellow-900/20', 'text-yellow-800', 'dark:text-yellow-300');
            }

            // Auto-hide after 3 seconds
            setTimeout(hideFeedbackStatus, 3000);
        }

        function hideFeedbackStatus() {
            const status = document.getElementById('feedbackCopyStatus');
            status.classList.add('hidden');
        }

        // Calculate content bounds for optimal PDF scaling
        function calculateContentBounds() {
            if (individuals.length === 0 && textBoxes.length === 0 && probandArrows.length === 0) {
                return { minX: 0, maxX: 800, minY: 0, maxY: 600, width: 800, height: 600 };
            }
            
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            
            // Include all individuals
            individuals.forEach(ind => {
                minX = Math.min(minX, ind.x - SYMBOL_RADIUS);
                maxX = Math.max(maxX, ind.x + SYMBOL_RADIUS);
                minY = Math.min(minY, ind.y - SYMBOL_RADIUS);
                maxY = Math.max(maxY, ind.y + SYMBOL_RADIUS);
            });
            
            // Include all text boxes
            textBoxes.forEach(tb => {
                minX = Math.min(minX, tb.x);
                maxX = Math.max(maxX, tb.x + tb.width);
                minY = Math.min(minY, tb.y);
                maxY = Math.max(maxY, tb.y + tb.height);
            });
            
            // Include all proband arrows
            probandArrows.forEach(arrow => {
                const endX = arrow.x + Math.cos(arrow.angle) * arrow.size;
                const endY = arrow.y + Math.sin(arrow.angle) * arrow.size;
                minX = Math.min(minX, arrow.x, endX);
                maxX = Math.max(maxX, arrow.x, endX);
                minY = Math.min(minY, arrow.y, endY);
                maxY = Math.max(maxY, arrow.y, endY);
            });
            
            // Add padding
            const padding = 40;
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            return {
                minX: minX,
                maxX: maxX,
                minY: minY,
                maxY: maxY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        
        function calculateLegendSpace(pdf) {
            const definedPatterns = patternDefinitions.filter(p => p.name && p.name.trim());
            
            if (definedPatterns.length === 0) {
                return { width: 0, height: 0 };
            }
            
            // Calculate space needed for legend - reserve more space to ensure visibility
            const thumbnailSize = 6;
            const lineHeight = 5;
            const titleHeight = 15;
            const legendWidth = 70; // Increased width to ensure legend visibility
            const legendHeight = titleHeight + (definedPatterns.length * lineHeight) + 10; // Extra padding
            
            return {
                width: legendWidth,
                height: legendHeight
            };
        }
        
        function calculateOptimalScaling(contentBounds, availableWidth, availableHeight) {
            // Calculate scale factors for both dimensions
            const scaleX = availableWidth / contentBounds.width;
            const scaleY = availableHeight / contentBounds.height;
            
            // Use the smaller scale to ensure content fits in both dimensions
            const scale = Math.min(scaleX, scaleY, 2.0); // Cap at 2x zoom for readability
            
            // Ensure minimum scale for very large family trees
            const finalScale = Math.max(scale, 0.3); // Minimum 30% scale
            
            // Calculate final dimensions
            const scaledWidth = contentBounds.width * finalScale;
            const scaledHeight = contentBounds.height * finalScale;
            
            // Calculate canvas dimensions (add some buffer)
            const canvasWidth = Math.ceil(scaledWidth * 1.1);
            const canvasHeight = Math.ceil(scaledHeight * 1.1);
            
            // Calculate PDF dimensions (convert from canvas pixels to mm at 96 DPI)
            const pdfWidth = Math.min(availableWidth, scaledWidth);
            const pdfHeight = Math.min(availableHeight, scaledHeight);
            
            return {
                scale: finalScale,
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                scaledWidth: scaledWidth,
                scaledHeight: scaledHeight,
                pdfWidth: pdfWidth,
                pdfHeight: pdfHeight,
                contentBounds: contentBounds
            };
        }
        
        function drawScaledPedigreeToCanvas(ctx, canvasWidth, canvasHeight, contentBounds, scaling) {
            // Clear canvas with white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Save context state
            ctx.save();
            
            // Calculate centering offset
            const offsetX = (canvasWidth - scaling.scaledWidth) / 2 - contentBounds.minX * scaling.scale;
            const offsetY = (canvasHeight - scaling.scaledHeight) / 2 - contentBounds.minY * scaling.scale;
            
            // Apply scaling and centering transformation
            ctx.translate(offsetX, offsetY);
            ctx.scale(scaling.scale, scaling.scale);
            
            // Draw subtle generation guide lines (scaled appropriately)
            ctx.globalAlpha = 0.2;
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1 / scaling.scale; // Adjust line width for scale
            ctx.setLineDash([3 / scaling.scale, 6 / scaling.scale]);
            
            SNAP_LINES.forEach((lineY, index) => {
                if (lineY >= contentBounds.minY && lineY <= contentBounds.maxY) {
                    ctx.beginPath();
                    ctx.moveTo(contentBounds.minX, lineY);
                    ctx.lineTo(contentBounds.maxX, lineY);
                    ctx.stroke();
                }
            });
            
            ctx.setLineDash([]);
            ctx.globalAlpha = 1.0;
            
            // Draw all connections first
            connections.forEach(connection => {
                // Temporarily adjust line width for scaling
                const originalLineWidth = ctx.lineWidth;
                connection.draw(ctx);
                ctx.lineWidth = originalLineWidth;
            });
            
            // Draw all individuals
            individuals.forEach(individual => {
                individual.draw(ctx);
            });
            
            // Draw all proband arrows
            probandArrows.forEach(arrow => {
                arrow.draw(ctx);
            });
            
            // Draw all text boxes
            textBoxes.forEach(textBox => {
                textBox.draw(ctx);
            });
            
            // Restore context state
            ctx.restore();
        }

        // Templates Modal Functions
        function openTemplatesModal() {
            document.getElementById('templatesModal').classList.remove('hidden');
        }
        
        function closeTemplatesModal() {
            document.getElementById('templatesModal').classList.add('hidden');
        }
        
        function insertTemplate(templateType) {
            // Save state before adding template
            saveState();
            
            // Clear current selections
            individuals.forEach(ind => ind.selected = false);
            connections.forEach(conn => conn.selected = false);
            textBoxes.forEach(tb => tb.selected = false);
            selectedIndividuals = [];
            
            // Calculate center position on canvas
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvas.width / (2 * window.devicePixelRatio);
            const centerY = canvas.height / (2 * window.devicePixelRatio);
            
            // Define template structures
            switch (templateType) {
                case 'maleWithGrandparents':
                    insertMaleWithGrandparentsTemplate(centerX, centerY);
                    break;
                case 'femaleWithGrandparents':
                    insertFemaleWithGrandparentsTemplate(centerX, centerY);
                    break;
                case 'pregnancyWithGrandparents':
                    insertPregnancyWithGrandparentsTemplate(centerX, centerY);
                    break;
            }
            
            closeTemplatesModal();
            draw();
            
            // Show success message
            const templateNames = {
                'maleWithGrandparents': 'Male Child with Grandparents',
                'femaleWithGrandparents': 'Female Child with Grandparents', 
                'pregnancyWithGrandparents': 'Pregnancy with Grandparents'
            };
            showBriefMessage(`Added template: ${templateNames[templateType]}`);
        }
        
        function insertMaleWithGrandparentsTemplate(centerX, centerY) {
            const spacing = 80; // Horizontal spacing between individuals
            
            // Calculate positions using the first three snap lines
            const gen1Y = SNAP_LINES[0]; // Grandparents
            const gen2Y = SNAP_LINES[1]; // Parents
            const gen3Y = SNAP_LINES[2]; // Child
            
            // Create individuals with unique IDs
            const now = Date.now();
            
            // Generation 1: Grandparents (left to right: paternal grandfather, paternal grandmother, maternal grandfather, maternal grandmother)
            const paternalGrandfather = new Individual(centerX - spacing * 1.5, gen1Y, 'male', now + 1);
            const paternalGrandmother = new Individual(centerX - spacing * 0.5, gen1Y, 'female', now + 2);
            const maternalGrandfather = new Individual(centerX + spacing * 0.5, gen1Y, 'male', now + 3);
            const maternalGrandmother = new Individual(centerX + spacing * 1.5, gen1Y, 'female', now + 4);
            
            // Generation 2: Parents
            const father = new Individual(centerX - spacing * 0.5, gen2Y, 'male', now + 5);
            const mother = new Individual(centerX + spacing * 0.5, gen2Y, 'female', now + 6);
            
            // Generation 3: Male child
            const child = new Individual(centerX, gen3Y, 'male', now + 7);
            
            // Add all individuals
            individuals.push(
                paternalGrandfather, paternalGrandmother, maternalGrandfather, maternalGrandmother,
                father, mother, child
            );
            
            // Create marriages
            const paternalMarriage = new Connection(paternalGrandfather, paternalGrandmother, 'marriage');
            const maternalMarriage = new Connection(maternalGrandfather, maternalGrandmother, 'marriage');
            const parentMarriage = new Connection(father, mother, 'marriage');
            
            // Create offspring connections
            const fatherToChild = new Connection(father, child, 'offspring');
            const motherToChild = new Connection(mother, child, 'offspring');
            const pgfToFather = new Connection(paternalGrandfather, father, 'offspring');
            const pgmToFather = new Connection(paternalGrandmother, father, 'offspring');
            const mgfToMother = new Connection(maternalGrandfather, mother, 'offspring');
            const mgmToMother = new Connection(maternalGrandmother, mother, 'offspring');
            
            connections.push(
                paternalMarriage, maternalMarriage, parentMarriage,
                fatherToChild, motherToChild, pgfToFather, pgmToFather, mgfToMother, mgmToMother
            );
        }
        
        function insertFemaleWithGrandparentsTemplate(centerX, centerY) {
            const spacing = 80;
            
            // Calculate positions using the first three snap lines
            const gen1Y = SNAP_LINES[0]; // Grandparents
            const gen2Y = SNAP_LINES[1]; // Parents
            const gen3Y = SNAP_LINES[2]; // Child
            
            const now = Date.now();
            
            // Generation 1: Grandparents
            const paternalGrandfather = new Individual(centerX - spacing * 1.5, gen1Y, 'male', now + 1);
            const paternalGrandmother = new Individual(centerX - spacing * 0.5, gen1Y, 'female', now + 2);
            const maternalGrandfather = new Individual(centerX + spacing * 0.5, gen1Y, 'male', now + 3);
            const maternalGrandmother = new Individual(centerX + spacing * 1.5, gen1Y, 'female', now + 4);
            
            // Generation 2: Parents
            const father = new Individual(centerX - spacing * 0.5, gen2Y, 'male', now + 5);
            const mother = new Individual(centerX + spacing * 0.5, gen2Y, 'female', now + 6);
            
            // Generation 3: Female child
            const child = new Individual(centerX, gen3Y, 'female', now + 7);
            
            // Add all individuals
            individuals.push(
                paternalGrandfather, paternalGrandmother, maternalGrandfather, maternalGrandmother,
                father, mother, child
            );
            
            // Create marriages
            const paternalMarriage = new Connection(paternalGrandfather, paternalGrandmother, 'marriage');
            const maternalMarriage = new Connection(maternalGrandfather, maternalGrandmother, 'marriage');
            const parentMarriage = new Connection(father, mother, 'marriage');
            
            // Create offspring connections
            const fatherToChild = new Connection(father, child, 'offspring');
            const motherToChild = new Connection(mother, child, 'offspring');
            const pgfToFather = new Connection(paternalGrandfather, father, 'offspring');
            const pgmToFather = new Connection(paternalGrandmother, father, 'offspring');
            const mgfToMother = new Connection(maternalGrandfather, mother, 'offspring');
            const mgmToMother = new Connection(maternalGrandmother, mother, 'offspring');
            
            connections.push(
                paternalMarriage, maternalMarriage, parentMarriage,
                fatherToChild, motherToChild, pgfToFather, pgmToFather, mgfToMother, mgmToMother
            );
        }
        
        function insertPregnancyWithGrandparentsTemplate(centerX, centerY) {
            const spacing = 80;
            
            // Calculate positions using the first three snap lines
            const gen1Y = SNAP_LINES[0]; // Grandparents
            const gen2Y = SNAP_LINES[1]; // Parents
            const gen3Y = SNAP_LINES[2]; // Pregnancy
            
            const now = Date.now();
            
            // Generation 1: Grandparents
            const paternalGrandfather = new Individual(centerX - spacing * 1.5, gen1Y, 'male', now + 1);
            const paternalGrandmother = new Individual(centerX - spacing * 0.5, gen1Y, 'female', now + 2);
            const maternalGrandfather = new Individual(centerX + spacing * 0.5, gen1Y, 'male', now + 3);
            const maternalGrandmother = new Individual(centerX + spacing * 1.5, gen1Y, 'female', now + 4);
            
            // Generation 2: Parents
            const father = new Individual(centerX - spacing * 0.5, gen2Y, 'male', now + 5);
            const mother = new Individual(centerX + spacing * 0.5, gen2Y, 'female', now + 6);
            
            // Generation 3: Pregnancy
            const pregnancy = new Individual(centerX, gen3Y, 'pregnancy', now + 7);
            
            // Add all individuals
            individuals.push(
                paternalGrandfather, paternalGrandmother, maternalGrandfather, maternalGrandmother,
                father, mother, pregnancy
            );
            
            // Create marriages
            const paternalMarriage = new Connection(paternalGrandfather, paternalGrandmother, 'marriage');
            const maternalMarriage = new Connection(maternalGrandfather, maternalGrandmother, 'marriage');
            const parentMarriage = new Connection(father, mother, 'marriage');
            
            // Create offspring connections
            const fatherToPregnancy = new Connection(father, pregnancy, 'offspring');
            const motherToPregnancy = new Connection(mother, pregnancy, 'offspring');
            const pgfToFather = new Connection(paternalGrandfather, father, 'offspring');
            const pgmToFather = new Connection(paternalGrandmother, father, 'offspring');
            const mgfToMother = new Connection(maternalGrandfather, mother, 'offspring');
            const mgmToMother = new Connection(maternalGrandmother, mother, 'offspring');
            
            connections.push(
                paternalMarriage, maternalMarriage, parentMarriage,
                fatherToPregnancy, motherToPregnancy, pgfToFather, pgmToFather, mgfToMother, mgmToMother
            );
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(draw, 100);
        });
    </script>
</body>
</html>













